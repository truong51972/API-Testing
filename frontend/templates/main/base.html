<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />
    <meta name="robots" content="noindex, nofollow" />
    <title>{% block title %}APIT{% endblock %}</title>
    {% load static %}
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Public+Sans:ital,wght@0,300;0,400;0,500;0,600;0,700&display=swap" rel="stylesheet" />
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="{% static 'assets/vendor/libs/pickr/pickr-themes.css' %}" />
    <link rel="stylesheet" href="{% static 'assets/vendor/fonts/iconify-icons.css' %}" />
    <link rel="stylesheet" href="{% static 'assets/vendor/css/core.css' %}" />
    <link rel="stylesheet" href="{% static 'assets/css/demo.css' %}" />
    <link rel="stylesheet" href="{% static 'assets/vendor/libs/perfect-scrollbar/perfect-scrollbar.css' %}" />
    <link rel="stylesheet" href="{% static 'assets/vendor/libs/apex-charts/apex-charts.css' %}" />
    <link rel="stylesheet"href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css">
    {% block extra_css %}{% endblock %}
    <link rel="stylesheet" href="{% static 'css/sidebar.css' %}">
    <link rel="stylesheet" href="{% static 'css/base.css' %}">
    <link rel="stylesheet" href="{% static 'css/message.css' %}">
    <link rel="stylesheet" href="{% static 'css/register.css' %}">
    <link rel="stylesheet" href="{% static 'css/login.css' %}">
    <script>
    // Apply sidebar state immediately before page render to prevent flash
    (function() {
        try {
            const savedState = localStorage.getItem('sidebarCollapsed');
            const isCollapsed = savedState === 'true';
            
            if (isCollapsed) {
                // Disable transitions and hide text immediately to prevent flash
                const style = document.createElement('style');
                style.id = 'sidebar-collapsed-inline';
                style.textContent = `
                    .sidebar-chatgpt { 
                        width: 70px !important; 
                        min-width: 70px !important; 
                        max-width: 70px !important;
                        transition: none !important;
                    }
                    .sidebar-chatgpt.collapsed .brand-text,
                    .sidebar-chatgpt.collapsed .nav-link span,
                    .sidebar-chatgpt.collapsed .nav-section-header span,
                    .sidebar-chatgpt.collapsed .nav-section-header,
                    .sidebar-chatgpt.collapsed .new-project-btn span,
                    .sidebar-chatgpt.collapsed .user-info,
                    .sidebar-chatgpt.collapsed .user-chevron,
                    .sidebar-chatgpt.collapsed .auth-btn span,
                    .sidebar-chatgpt.collapsed span:not([class*="tooltip"]) {
                        display: none !important;
                        opacity: 0 !important;
                        visibility: hidden !important;
                        font-size: 0 !important;
                    }
                    .sidebar-chatgpt.collapsed .nav-item.project-item,
                    .sidebar-chatgpt.collapsed .project-divider {
                        display: none !important;
                    }
                    main { 
                        width: calc(100vw - 70px) !important; 
                        max-width: calc(100vw - 70px) !important;
                        transition: none !important;
                    }
                    body > .d-flex > .sidebar-chatgpt {
                        width: 70px !important;
                        min-width: 70px !important;
                        max-width: 70px !important;
                    }
                `;
                if (document.head) {
                    document.head.appendChild(style);
                } else {
                    // Fallback for older browsers
                    const script = document.createElement('script');
                    script.textContent = 'document.write("' + style.outerHTML.replace(/"/g, '\\"') + '");';
                    document.head ? document.head.appendChild(script) : (document.body ? document.body.appendChild(script) : null);
                }
            }
        } catch(e) {
            // Ignore errors if localStorage is not available
        }
    })();
    </script>
    <style>

    </style>
</head>

<body>
    <div class="d-flex">
        {% include "main/sidebar.html" %}

        <main class="flex-grow-1 p-4">
            <!-- Global Loading Overlay - Disabled by default -->
            <div id="global-loading-overlay" style="display:none;">
                <div class="global-loading-backdrop"></div>
                <div class="global-loading-spinner">
                    <div class="spinner-border text-primary" role="status"></div>
                    <div class="mt-2 small text-muted">Đang xử lý...</div>
                </div>
            </div>
            <!-- Global Notification Container -->
            <div id="global-notification-container" class="notification-container"></div>
            
            <!-- Django Messages Container - Hidden by default, will be converted to notifications -->
            {% if messages %}
            <div id="django-messages-container" style="display: none;">
                {% for message in messages %}
                <div class="alert alert-{{ message.tags }} alert-dismissible fade show" role="alert" data-message-id="{{ forloop.counter }}">
                    <i class="bi bi-info-circle me-2"></i>{{ message }}
                    <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
                </div>
                {% endfor %}
            </div>
            {% endif %}


            {% block content %}{% endblock %}
        </main>
    </div>

    <script>
        // Simple Loading Overlay Controller
        document.addEventListener('DOMContentLoaded', function() {
            const overlay = document.getElementById('global-loading-overlay');
            if (overlay) {
                overlay.style.display = 'none';
            }

            window.__loadingOverlay = {
                show: function() {
                    if (overlay) overlay.style.display = 'block';
                },
                hide: function() {
                    if (overlay) overlay.style.display = 'none';
                }
            };
        });

        // Enhanced fetch wrapper with automatic loading overlay
        const originalFetch = window.fetch;
        window.fetch = function(url, options = {}) {
            // Extract custom options
            const noLoading = options._noLoading === true;
            const timeoutMs = options._timeoutMs || 30000;
            const retries = options._retries || 0;
            
            // Remove custom options from fetch options
            const fetchOptions = { ...options };
            delete fetchOptions._noLoading;
            delete fetchOptions._timeoutMs;
            delete fetchOptions._retries;

            // Ensure headers object exists and add Authorization header
            if (!fetchOptions.headers) {
                fetchOptions.headers = {};
            }
            
            // Handle different header types
            if (fetchOptions.headers instanceof Headers) {
                // If it's already a Headers object, just add Authorization if not present
                if (!fetchOptions.headers.has('Authorization')) {
                    fetchOptions.headers.set('Authorization', 'Basic YWRtaW46YWRtaW4=');
                }
            } else if (typeof fetchOptions.headers === 'object' && fetchOptions.headers !== null) {
                // If headers is a plain object, add Authorization if not already present
                if (!fetchOptions.headers['Authorization'] && !fetchOptions.headers['authorization']) {
                    fetchOptions.headers['Authorization'] = 'Basic YWRtaW46YWRtaW4=';
                }
            }

            // Show loading overlay if not disabled
            let loadingShown = false;
            if (!noLoading) {
                // Try to show loading overlay (works even before DOMContentLoaded)
                if (window.__loadingOverlay) {
                    window.__loadingOverlay.show();
                    loadingShown = true;
                } else {
                    // If overlay not initialized yet, try to get it directly
                    const overlay = document.getElementById('global-loading-overlay');
                    if (overlay) {
                        overlay.style.display = 'block';
                        loadingShown = true;
                    }
                }
            }

            // Create fetch promise with timeout and retry logic
            let attemptCount = 0;
            const fetchWithRetry = async () => {
                attemptCount++;
                try {
                    // Create abort controller for timeout
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => {
                        controller.abort();
                    }, timeoutMs);

                    // Add signal to fetch options if not already present
                    if (!fetchOptions.signal) {
                        fetchOptions.signal = controller.signal;
                    }

                    const fetchPromise = originalFetch(url, fetchOptions);
                    const response = await fetchPromise;
                    
                    clearTimeout(timeoutId);
                    return response;
                } catch (error) {
                    // Check if it's an abort error (timeout) or network error
                    const isRetryable = error.name === 'AbortError' || 
                                       error.message.includes('timeout') || 
                                       error.message.includes('Failed to fetch') ||
                                       error.message.includes('NetworkError');
                    
                    if (attemptCount <= retries && isRetryable) {
                        console.log(`Retrying fetch (attempt ${attemptCount}/${retries + 1})...`);
                        await new Promise(resolve => setTimeout(resolve, 1000 * attemptCount)); // Exponential backoff
                        return fetchWithRetry();
                    }
                    throw error;
                }
            };

            // Execute fetch with retry
            return fetchWithRetry()
                .then(response => {
                    // Hide loading overlay
                    if (loadingShown) {
                        if (window.__loadingOverlay) {
                            window.__loadingOverlay.hide();
                        } else {
                            const overlay = document.getElementById('global-loading-overlay');
                            if (overlay) {
                                overlay.style.display = 'none';
                            }
                        }
                    }
                    return response;
                })
                .catch(error => {
                    // Hide loading overlay on error
                    if (loadingShown) {
                        if (window.__loadingOverlay) {
                            window.__loadingOverlay.hide();
                        } else {
                            const overlay = document.getElementById('global-loading-overlay');
                            if (overlay) {
                                overlay.style.display = 'none';
                            }
                        }
                    }
                    throw error;
                });
        };

        // Simplified fetch wrapper - no auto loading
        window.parseJsonSafe = async function(response) {
            const text = await response.text();
            try {
                return JSON.parse(text);
            } catch (e) {
                return { ok: response.ok, status: response.status, raw: text };
            }
        };

        // Enhanced notification system
        document.addEventListener('DOMContentLoaded', function() {
            // Clear any old notifications from localStorage
            const lastCleared = localStorage.getItem('notifications_last_cleared');
            const now = Date.now();
            if (!lastCleared || (now - parseInt(lastCleared)) > 300000) { // 5 minutes
                localStorage.removeItem('messages_displayed');
                localStorage.setItem('notifications_last_cleared', now.toString());
            }

            // Enhanced notification functionality
            window.showNotification = function(type, title, message = '', options = {}) {
                const container = document.getElementById('global-notification-container');
                if (!container) return;

                // Map types to Bootstrap classes
                const typeMap = {
                    'success': 'success',
                    'error': 'danger', 
                    'warning': 'warning',
                    'info': 'info',
                    'danger': 'danger'
                };

                const alertClass = typeMap[type] || 'info';
                const iconMap = {
                    'success': 'check-circle',
                    'error': 'exclamation-triangle',
                    'warning': 'exclamation-triangle', 
                    'info': 'info-circle',
                    'danger': 'exclamation-triangle'
                };
                const icon = iconMap[type] || 'info-circle';

                // Create unique ID for this notification
                const notificationId = 'notif_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                
                const notificationHtml = `
                    <div class="notification ${alertClass}" id="${notificationId}">
                        <div class="notification-icon">
                            <i class="bi bi-${icon}"></i>
                        </div>
                        <div class="notification-content">
                            <div class="notification-title">${title}</div>
                            ${message ? `<div class="notification-message">${message}</div>` : ''}
                        </div>
                        <button class="notification-close" onclick="removeNotification('${notificationId}')">
                            <i class="bi bi-x"></i>
                        </button>
                        <div class="notification-progress"></div>
                    </div>
                `;

                container.insertAdjacentHTML('beforeend', notificationHtml);

                // Auto remove after timeout (default 3 seconds)
                const timeout = options.timeout || 3000;
                setTimeout(() => {
                    removeNotification(notificationId);
                }, timeout);
            };

            // Function to remove notification
            window.removeNotification = function(notificationId) {
                const notification = document.getElementById(notificationId);
                if (notification) {
                    // Stop progress bar animation
                    const progressBar = notification.querySelector('.notification-progress');
                    if (progressBar) {
                        progressBar.style.animationPlayState = 'paused';
                    }
                    
                    notification.classList.add('removing');
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.parentNode.removeChild(notification);
                        }
                    }, 300);
                }
            };

            // Clear all notifications
            window.clearAllNotifications = function() {
                const container = document.getElementById('global-notification-container');
                if (container) {
                    container.innerHTML = '';
                }
            };

            // Convert Django messages to notifications
            const djangoMessagesContainer = document.getElementById('django-messages-container');
            if (djangoMessagesContainer) {
                const messages = djangoMessagesContainer.querySelectorAll('.alert');
                messages.forEach((message, index) => {
                    const messageText = message.textContent.trim();
                    const messageType = message.classList.contains('alert-success') ? 'success' :
                                      message.classList.contains('alert-danger') ? 'error' :
                                      message.classList.contains('alert-warning') ? 'warning' :
                                      message.classList.contains('alert-info') ? 'info' : 'info';
                    
                    // Show notification with slight delay to avoid overlap
                    setTimeout(() => {
                        showNotification(messageType, '', messageText, { timeout: 3000 });
                    }, index * 200);
                });
            }

            // Add loading overlay for form submissions
            const forms = document.querySelectorAll('form:not([data-no-loading])');
            forms.forEach(form => {
                form.addEventListener('submit', function(e) {
                    // Check if form has data-no-loading attribute
                    if (form.hasAttribute('data-no-loading')) {
                        return;
                    }
                    
                    // Check if form is file upload (has file input)
                    const hasFileInput = form.querySelector('input[type="file"]');
                    if (hasFileInput) {
                        // File uploads will be handled by their own loading states
                        return;
                    }

                    // Show loading overlay for regular form submissions
                    if (window.__loadingOverlay) {
                        window.__loadingOverlay.show();
                    }

                    // Hide loading after a delay (in case page doesn't reload)
                    setTimeout(() => {
                        if (window.__loadingOverlay) {
                            window.__loadingOverlay.hide();
                        }
                    }, 5000);
                });
            });

            // Add loading overlay for navigation links that might load data
            const navLinks = document.querySelectorAll('a[href*="/project/"], a[href*="/api/"]');
            navLinks.forEach(link => {
                // Skip if link has data-no-loading attribute
                if (link.hasAttribute('data-no-loading')) {
                    return;
                }

                link.addEventListener('click', function(e) {
                    // Only show loading for links that might trigger API calls
                    const href = this.getAttribute('href');
                    if (href && (href.includes('/project/list') || href.includes('/api/'))) {
                        if (window.__loadingOverlay) {
                            window.__loadingOverlay.show();
                        }
                    }
                });
            });
        });


    </script>

</body>

</html>

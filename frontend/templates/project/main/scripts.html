<script>
    // Function to handle file upload (used by both click and drag-drop)
    function handleFileUpload(files) {
        if (!files || files.length === 0) return;

        // Filter files to only accept .docx and .pdf
        const allowedTypes = ['.docx', '.pdf'];
        const validFiles = Array.from(files).filter(file => {
            const fileName = file.name.toLowerCase();
            return allowedTypes.some(type => fileName.endsWith(type));
        });

        if (validFiles.length === 0) {
            showNotification('warning', 'Cảnh báo', 'Vui lòng chọn file .docx hoặc .pdf');
            return;
        }

        if (validFiles.length < files.length) {
            showNotification('info', 'Thông báo', `Đã bỏ qua ${files.length - validFiles.length} file không hợp lệ. Chỉ upload ${validFiles.length} file .docx/.pdf`);
        }

        // Create a new FileList-like object and set it to the input
        const dataTransfer = new DataTransfer();
        validFiles.forEach(file => dataTransfer.items.add(file));
        const fileInput = document.getElementById('fileInput');
        fileInput.files = dataTransfer.files;

        // Trigger the change event to use existing upload logic
        fileInput.dispatchEvent(new Event('change', { bubbles: true }));
    }

    // File input change event handler
    document.getElementById('fileInput').addEventListener('change', function () {
        if (this.files.length > 0) {
            // Show loading state for file upload
            const uploadBox = document.querySelector('.upload-box');
            const originalContent = uploadBox.innerHTML;
            const fileCount = this.files.length;
            const fileText = fileCount === 1 ? 'file' : 'files';
            uploadBox.innerHTML = `
            <i class="bi bi-hourglass-split" style="font-size: 2rem;"></i>
            <p class="mt-2">Uploading ${fileCount} ${fileText}...</p>
            <small class="text-muted">Please wait while we upload your files</small>
        `;
            uploadBox.style.pointerEvents = 'none';

            // Show global loading overlay
            if (window.__loadingOverlay) {
                window.__loadingOverlay.show();
            }

            document.getElementById('uploadForm').submit();
        }
    });

    // Drag & Drop functionality
    document.addEventListener('DOMContentLoaded', function () {
        const uploadBox = document.querySelector('.upload-box');
        const fileInput = document.getElementById('fileInput');

        if (!uploadBox || !fileInput) return;

        // Prevent default drag behaviors on the document
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            uploadBox.addEventListener(eventName, preventDefaults, false);
            document.body.addEventListener(eventName, preventDefaults, false);
        });

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        // Highlight drop area when item is dragged over it
        ['dragenter', 'dragover'].forEach(eventName => {
            uploadBox.addEventListener(eventName, function (e) {
                uploadBox.classList.add('drag-over');
            }, false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
            uploadBox.addEventListener(eventName, function (e) {
                uploadBox.classList.remove('drag-over');
            }, false);
        });

        // Handle dropped files
        uploadBox.addEventListener('drop', function (e) {
            const dt = e.dataTransfer;
            const files = dt.files;

            if (files.length > 0) {
                handleFileUpload(files);
            }
        }, false);
    });

    // Link upload form loading state
    document.getElementById('linkUploadForm').addEventListener('submit', function (e) {
        const linkInput = document.getElementById('docLink');
        const submitBtn = document.getElementById('linkUploadBtn');

        if (!linkInput.value.trim()) {
            e.preventDefault();
            showNotification('warning', 'Cảnh báo', 'Vui lòng nhập URL hợp lệ');
            return;
        }

        // Show loading state
        const originalText = submitBtn.innerHTML;
        submitBtn.disabled = true;
        submitBtn.innerHTML = '<i class="bi bi-hourglass-split"></i> Processing...';

        // Show global loading overlay
        if (window.__loadingOverlay) {
            window.__loadingOverlay.show();
        }

        // Store original text for restoration if needed
        submitBtn.setAttribute('data-original-text', originalText);
    });
</script>

<script>
    let currentStep = 1;
    let totalSteps = 5;
    const projectUuid = '{{ project.uuid }}';

    // Restore current step from localStorage on page load
    (function () {
        const savedStep = localStorage.getItem(`project_step_${projectUuid}`);
        if (savedStep) {
            const stepNum = parseInt(savedStep, 10);
            if (stepNum >= 1 && stepNum <= totalSteps) {
                currentStep = stepNum;
            }
        }
    })();

    function setStep(n) {
        const steps = document.querySelectorAll('.step');
        steps.forEach((s, i) => {
            s.classList.remove('active', 'completed');
            if (i < n - 1) s.classList.add('completed'); // bước đã qua
            if (i === n - 1) s.classList.add('active');  // bước hiện tại
        });
        currentStep = n;

        // Save current step to localStorage
        localStorage.setItem(`project_step_${projectUuid}`, n.toString());

        // Update URL để remove query param step cũ (trừ khi có report_id)
        // Điều này đảm bảo khi reload sẽ dùng localStorage thay vì query param
        const url = new URL(window.location.href);
        const hasReportId = url.searchParams.has('report_id');

        // Chỉ update URL nếu không có report_id (vì report_id cần giữ lại)
        if (!hasReportId) {
            // Remove step param từ URL để khi reload sẽ dùng localStorage
            url.searchParams.delete('step');
            // Update URL mà không reload page
            window.history.replaceState({}, '', url.toString());
        }

        // Ẩn/hiện nội dung theo step
        document.querySelectorAll('.phase').forEach(el => el.classList.add('d-none'));
        const currentPhase = document.getElementById('phase' + n);
        if (currentPhase) currentPhase.classList.remove('d-none');

        // Điều khiển hiển thị nút Back và Next theo từng step
        updateNavigationButtons(n);

        // Cập nhật lock status cho các step
        updateStepLocks();
    }

    // Helper function to update navigation buttons visibility
    function updateNavigationButtons(step) {
        const nextButton = document.getElementById('nextButton');
        const backButton = document.getElementById('backButton');

        if (nextButton) {
            // Ẩn Next ở step 5 (bước cuối) và step 2 (AI tự xử lý)
            // Step 4: chỉ ẩn nếu chưa chọn test cases (AI đang xử lý)
            if (step === totalSteps || step === 2) {
                nextButton.style.display = 'none';
            } else if (step === 4) {
                // Step 4: hiển thị Next nếu đã chọn test cases
                if (window.testCasesSelected) {
                    nextButton.style.display = 'inline-block';
                } else {
                    nextButton.style.display = 'none';
                }
            } else {
                nextButton.style.display = 'inline-block';
            }
        }

        if (backButton) {
            // Ẩn Back ở step 1 (bước đầu) và step 2 (AI tự xử lý)
            // Step 4: chỉ ẩn nếu chưa chọn test cases (AI đang xử lý)
            if (step === 1 || step === 2) {
                backButton.style.display = 'none';
            } else if (step === 4) {
                // Step 4: hiển thị Back nếu đã chọn test cases
                if (window.testCasesSelected) {
                    backButton.style.display = 'inline-block';
                } else {
                    backButton.style.display = 'none';
                }
            } else {
                backButton.style.display = 'inline-block';
            }
        }
    }

    // Function to load report directly from report_id (without polling)
    function loadReportFromId(projectUuid, testSuiteReportId) {
        console.log('Loading report directly from ID:', testSuiteReportId);
        loadMultipleReports(projectUuid, [testSuiteReportId]);
    }

    // Function to load multiple reports
    function loadMultipleReports(projectUuid, reportIds) {
        console.log('Loading multiple reports:', reportIds);

        // Set step to 5 (report phase)
        setStep(5);

        // Show loading state
        showTestExecutionStatus();
        updateTestExecutionStatus(`Đang tải ${reportIds.length} report(s)...`);

        // Fetch all reports in parallel
        const fetchPromises = reportIds.map(reportId => 
            fetch(`/project/${projectUuid}/test-report/${reportId}/`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]')?.value || ''
                }
            })
                .then(response => response.json())
                .then(data => ({ reportId, data }))
                .catch(error => {
                    console.error(`Error loading report ${reportId}:`, error);
                    return { reportId, error };
                })
        );

        Promise.all(fetchPromises).then(results => {
            let successCount = 0;
            let errorCount = 0;

            results.forEach(({ reportId, data, error }) => {
                if (error) {
                    errorCount++;
                    console.error(`❌ Error loading report ${reportId}:`, error);
                } else if (data.success) {
                    successCount++;
                    console.log(`✅ Report ${reportId} loaded successfully!`);
                    // Display report (append mode for multiple reports)
                    displayTestReport(data, reportId, successCount > 1);
                } else {
                    errorCount++;
                    console.error(`❌ Error loading report ${reportId}:`, data.message);
                }
            });

            hideTestExecutionStatus();
            
            if (successCount > 0) {
                window.testReportReady = true;
                if (successCount === reportIds.length) {
                    showNotification('success', 'Thành công', `Đã tải ${successCount} report(s) thành công.`);
                } else {
                    showNotification('warning', 'Cảnh báo', `Đã tải ${successCount}/${reportIds.length} report(s). ${errorCount} report(s) có lỗi.`);
                }
            } else {
                showNotification('error', 'Lỗi!', 'Không thể tải bất kỳ report nào.');
            }
        });
    }

    // Hàm xử lý khi click vào step icon
    function goToStep(n) {
        // Kiểm tra nếu AI đang processing, chỉ cho phép step 1 và 2
        if (window.aiProcessingInProgress && n !== 1 && n !== 2) {
            if (typeof showNotification === 'function') {
                showNotification('warning', 'Cảnh báo', 'AI đang xử lý documents. Vui lòng đợi quá trình hoàn thành trước khi chuyển sang các bước khác.');
            }
            return;
        }

        // Kiểm tra xem step có được unlock không
        if (!isStepUnlocked(n)) {
            const maxUnlocked = getMaxUnlockedStep();
            let message = '';

            if (n === 3) {
                message = 'Vui lòng hoàn thành bước 2 (AI Extract) trước khi chuyển sang bước 3.';
            } else if (n === 4) {
                message = 'Vui lòng hoàn thành bước 3 (View FRs - chọn và lưu FR) trước khi chuyển sang bước 4.';
            } else if (n === 5) {
                message = 'Vui lòng hoàn thành bước 4 (AI Test Case - chọn test cases) trước khi chuyển sang bước 5.';
            } else {
                message = `Bước ${n} chưa được mở khóa. Vui lòng hoàn thành bước ${maxUnlocked} trước.`;
            }

            if (typeof showNotification === 'function') {
                showNotification('warning', 'Cảnh báo', message);
            }
            return;
        }

        // Nếu click vào step 2 và có documents đã completed, chuyển sang step 3
        if (n === 2 && window.hasCompletedDocuments) {
            // Hiển thị thông báo và chuyển sang step 3
            if (typeof showNotification === 'function') {
                showNotification('info', 'Thông báo', 'Documents đã được xử lý. Chuyển sang bước chọn FR.');
            }
            setStep(3);
            // Load sections
            if (typeof loadSections === 'function') {
                setTimeout(() => {
                    loadSections();
                }, 300);
            }
            return;
        }

        // Cho các step khác, gọi setStep bình thường
        setStep(n);

        // Xử lý các logic đặc biệt cho từng step
        setTimeout(() => {
            if (n === 2 && typeof startAIProcessing === 'function') {
                // Nếu chuyển đến step 2, bắt đầu AI processing
                startAIProcessing(projectUuid);
            } else if (n === 3 && typeof loadSections === 'function') {
                // Nếu chuyển đến step 3, load sections
                loadSections();
            } else if (n === 4 && typeof startTestCaseGeneration === 'function') {
                // Nếu chuyển đến step 4, bắt đầu test case generation
                startTestCaseGeneration(projectUuid);
            }
        }, 300);
    }

    // Restore step on page load
    document.addEventListener('DOMContentLoaded', function () {
        // Ưu tiên check URL query param nếu có (cho deep linking)
        const params = new URLSearchParams(window.location.search);
        const stepParam = params.get('step');
        const reportId = params.get('report_id');
        const reportIds = params.get('report_ids');

        // Nếu có report_id trong URL, tự động set step về 5 (Report step)
        let stepToSet = currentStep; // currentStep đã được restore từ localStorage ở IIFE

        if (reportId || reportIds) {
            // Khi có report_id, luôn chuyển về step 5 (Report)
            stepToSet = 5;
            // Lưu vào localStorage để lần sau reload sẽ dùng step này
            localStorage.setItem(`project_step_${projectUuid}`, '5');
            // Cập nhật currentStep để đồng bộ
            currentStep = 5;
        } else if (stepParam) {
            // Nếu có step param trong URL, sử dụng nó (cho deep linking)
            const stepNum = parseInt(stepParam, 10);
            if (!isNaN(stepNum) && stepNum >= 1 && stepNum <= totalSteps) {
                stepToSet = stepNum;
                // Lưu vào localStorage để lần sau reload sẽ dùng step này
                localStorage.setItem(`project_step_${projectUuid}`, stepNum.toString());
                // Cập nhật currentStep để đồng bộ
                currentStep = stepNum;
            }
        } else {
            // Nếu không có query param, đảm bảo dùng step từ localStorage
            // currentStep đã được restore từ localStorage ở IIFE, nên chỉ cần dùng nó
            stepToSet = currentStep;
        }

        setStep(stepToSet);

        // Thêm event listener cho các step icon để có thể click vào chúng
        const steps = document.querySelectorAll('.step');
        steps.forEach((step, index) => {
            const stepNumber = index + 1;

            // Thêm event listener cho click
            step.addEventListener('click', function () {
                // Chỉ cho phép click nếu step được unlock
                if (isStepUnlocked(stepNumber)) {
                    goToStep(stepNumber);
                }
            });
        });

        // Check if report_id(s) is in URL query params and auto-load report(s)
        // Nếu có report_id, đảm bảo step được set về 5 trước khi load report
        if (reportId || reportIds) {
            // Đảm bảo step được set về 5 ngay lập tức (không chờ delay)
            if (stepToSet !== 5) {
                setStep(5);
            }
            // Set testReportReady flag để unlock step 5
            window.testReportReady = true;
        }

        // Cập nhật lock status ban đầu (sau khi đã set testReportReady nếu có report_id)
        updateStepLocks();

        if (reportId) {
            // Single report ID (legacy support)
            setTimeout(() => {
                loadReportFromId(projectUuid, reportId);
            }, 500);
        } else if (reportIds) {
            // Multiple report IDs (comma-separated)
            const reportIdArray = reportIds.split(',').filter(id => id.trim());
            if (reportIdArray.length > 0) {
                setTimeout(() => {
                    loadMultipleReports(projectUuid, reportIdArray);
                }, 500);
            }
        } else {
            // Try to load from localStorage as backup
            const savedReports = localStorage.getItem(`project_reports_${projectUuid}`);
            if (savedReports) {
                try {
                    const reportIdArray = JSON.parse(savedReports);
                    if (Array.isArray(reportIdArray) && reportIdArray.length > 0) {
                        // Nếu load từ localStorage, cũng set step về 5
                        setStep(5);
                        setTimeout(() => {
                            loadMultipleReports(projectUuid, reportIdArray);
                        }, 500);
                    }
                } catch (e) {
                    console.error('Error parsing saved reports from localStorage:', e);
                }
            }
        }

        // Auto-load data for specific steps (chỉ khi không có report_id)
        // Nếu có report_id, đã set step về 5 và sẽ load report, không cần load data cho các step khác
        if (!reportId && !reportIds) {
            if (stepToSet === 2) {
                // If on step 2, check if we need to start AI processing or FR extraction
                // This will be handled by startAIProcessing or checkAIStatusLoop
            } else if (stepToSet === 3) {
                // Load sections for step 3
                setTimeout(() => {
                    if (typeof loadSections === 'function') {
                        loadSections();
                    }
                }, 300);
            } else if (stepToSet === 4) {
                // If restoring to step 4, automatically load test cases if they exist
                setTimeout(() => {
                    if (typeof startTestCaseGeneration === 'function') {
                        startTestCaseGeneration(projectUuid);
                    }
                }, 500);
            }
        }
    });

    function nextStep() {
        if (currentStep === 1) {
            // Kiểm tra xem có documents nào đã được xử lý (completed) không
            // Nếu có, chuyển thẳng sang phase 3 (FR Selection) bỏ qua phase 2
            if (window.hasCompletedDocuments) {
                setStep(3);
                loadSections();
                return;
            }

            // Nếu không có documents completed, chuyển sang phase 2 như bình thường
            setStep(2);
            // Auto start AI processing when entering step 2
            setTimeout(() => {
                startAIProcessing('{{ project.uuid }}');
            }, 500);
        } else if (currentStep === 2) {
            // Check if both AI processing and FR extraction are completed
            const aiStatus = document.getElementById('aiStatusText').textContent;
            const isAIComplete = aiStatus.includes('Completed') || window.aiProcessingComplete;
            const isFRComplete = window.frExtractionComplete || aiStatus.includes('FR Extraction Completed');

            if (isAIComplete && isFRComplete) {
                setStep(3);
                loadSections();
            } else if (!isAIComplete) {
                showNotification('warning', 'Cảnh báo', 'Vui lòng chờ AI xử lý hoàn thành.');
            } else if (!isFRComplete) {
                showNotification('warning', 'Cảnh báo', 'Vui lòng chờ trích xuất Functional Requirements hoàn thành.');
            }
        } else if (currentStep === 3) {
            // Check if at least one FR is selected (checkboxes are saved automatically)
            const selectedFRs = Array.from(document.querySelectorAll('.fr-checkbox:checked'));

            // If no FRs are currently checked, require selection
            if (selectedFRs.length === 0) {
                showNotification('warning', 'Cảnh báo', 'Vui lòng chọn ít nhất một Functional Requirement (FR) trước khi tiếp tục.');
                return;
            }

            // Selections are saved automatically when checkboxes are toggled, so we can proceed
            // All validations passed, proceed to next step
            setStep(4);
            // Auto start AI test case generation when entering step 4
            setTimeout(() => {
                startTestCaseGeneration('{{ project.uuid }}');
            }, 500);
        } else if (currentStep === 4) {
            // Check if test cases have been selected
            if (!window.testCasesSelected) {
                showNotification('warning', 'Cảnh báo', 'Vui lòng chọn test cases và bấm "Xác Nhận Chọn Test Cases" trước khi tiếp tục.');
                return;
            }

            // Move to step 5 and start executing test suite
            setStep(5);

            // Start executing test suite - lấy tất cả test suite IDs từ selected test cases
            setTimeout(() => {
                // Luôn lấy tất cả test suite IDs từ selected test cases để support multiple suites
                const testSuiteIds = getUniqueTestSuiteIdsFromSelected();
                if (testSuiteIds.length > 0) {
                    console.log(`Found ${testSuiteIds.length} test suite(s) from selected test cases:`, testSuiteIds);
                    executeTestSuite('{{ project.uuid }}', testSuiteIds);
                } else {
                    // Fallback: nếu không tìm thấy từ selected test cases, thử lấy từ database
                    console.warn('No test suite IDs found from selected test cases, trying database...');
                    getTestSuiteIdFromDatabase('{{ project.uuid }}');
                }
            }, 500);
        } else if (currentStep < totalSteps) {
            setStep(currentStep + 1);
        }
    }

    function prevStep() {
        if (currentStep > 1) {
            setStep(currentStep - 1);
        }
    }

    // Initialize flags for tracking processing status
    window.aiProcessingComplete = false;
    window.aiProcessingInProgress = false; // Track if AI is currently processing
    window.frExtractionComplete = false;
    window.frSelectionsSaved = false; // Track if FR selections have been saved at least once
    window.currentProjectUuid = '{{ project.uuid }}'; // Store project UUID globally
    window.testReportReady = false; // Track if test report is ready
    window.testCasesSelected = false; // Track if test cases have been selected
    window.selectedTestSuiteId = null; // Store selected test suite ID

    // Store original states of disabled elements
    window.disabledElements = [];

    // Hàm tạo blocking overlay để chặn tất cả tương tác
    function createBlockingOverlay() {
        // Kiểm tra xem overlay đã tồn tại chưa
        let overlay = document.getElementById('ai-processing-blocking-overlay');
        if (!overlay) {
            overlay = document.createElement('div');
            overlay.id = 'ai-processing-blocking-overlay';
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.5);
                z-index: 99999;
                display: flex;
                align-items: center;
                justify-content: center;
                backdrop-filter: blur(2px);
            `;

            const content = document.createElement('div');
            content.style.cssText = `
                background: white;
                padding: 30px;
                border-radius: 10px;
                text-align: center;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                max-width: 400px;
            `;

            content.innerHTML = `
                <div class="spinner-border text-primary mb-3" role="status" style="width: 3rem; height: 3rem;">
                    <span class="visually-hidden">Loading...</span>
                </div>
                <h5 class="mb-2">AI đang xử lý...</h5>
                <p class="text-muted mb-0">Vui lòng đợi quá trình hoàn thành. Bạn không thể thao tác trên màn hình lúc này.</p>
            `;

            overlay.appendChild(content);
            document.body.appendChild(overlay);
        }
        overlay.style.display = 'flex';
        return overlay;
    }

    // Hàm ẩn blocking overlay
    function hideBlockingOverlay() {
        const overlay = document.getElementById('ai-processing-blocking-overlay');
        if (overlay) {
            overlay.style.display = 'none';
        }
    }

    // Hàm disable tất cả interactive elements
    function disableAllInteractiveElements() {
        window.disabledElements = [];

        // Disable tất cả buttons (trừ các button trong phase 2 - AI processing)
        const buttons = document.querySelectorAll('button:not(#ai-processing-blocking-overlay button)');
        buttons.forEach(btn => {
            if (!btn.disabled && !btn.closest('#phase2')) {
                btn.setAttribute('data-originally-enabled', 'true');
                btn.disabled = true;
                window.disabledElements.push(btn);
            }
        });

        // Disable tất cả links
        const links = document.querySelectorAll('a:not(#ai-processing-blocking-overlay a)');
        links.forEach(link => {
            if (!link.hasAttribute('data-originally-disabled')) {
                link.setAttribute('data-originally-enabled', 'true');
                link.style.pointerEvents = 'none';
                link.style.opacity = '0.5';
                window.disabledElements.push(link);
            }
        });

        // Disable tất cả inputs và textareas
        const inputs = document.querySelectorAll('input:not(#ai-processing-blocking-overlay input), textarea:not(#ai-processing-blocking-overlay textarea), select:not(#ai-processing-blocking-overlay select)');
        inputs.forEach(input => {
            if (!input.disabled && !input.closest('#phase2')) {
                input.setAttribute('data-originally-enabled', 'true');
                input.disabled = true;
                window.disabledElements.push(input);
            }
        });

        // Disable tất cả forms
        const forms = document.querySelectorAll('form:not(#ai-processing-blocking-overlay form)');
        forms.forEach(form => {
            if (!form.hasAttribute('data-originally-disabled')) {
                form.setAttribute('data-originally-enabled', 'true');
                form.style.pointerEvents = 'none';
                form.style.opacity = '0.5';
                window.disabledElements.push(form);
            }
        });

        // Prevent clicks on step icons
        const steps = document.querySelectorAll('.step');
        steps.forEach(step => {
            if (!step.hasAttribute('data-originally-disabled')) {
                step.setAttribute('data-originally-enabled', 'true');
                step.style.pointerEvents = 'none';
                window.disabledElements.push(step);
            }
        });
    }

    // Hàm enable lại tất cả interactive elements
    function enableAllInteractiveElements() {
        window.disabledElements.forEach(element => {
            if (element.hasAttribute('data-originally-enabled')) {
                if (element.tagName === 'BUTTON' || element.tagName === 'INPUT' || element.tagName === 'TEXTAREA' || element.tagName === 'SELECT') {
                    element.disabled = false;
                } else {
                    element.style.pointerEvents = '';
                    element.style.opacity = '';
                }
                element.removeAttribute('data-originally-enabled');
            }
        });
        window.disabledElements = [];
    }

    // Hàm block tất cả tương tác khi AI processing
    function blockAllInteractions() {
        createBlockingOverlay();
        disableAllInteractiveElements();
    }

    // Hàm unblock tất cả tương tác khi AI processing hoàn thành
    function unblockAllInteractions() {
        hideBlockingOverlay();
        enableAllInteractiveElements();
    }

    // Hàm kiểm tra step có được unlock không
    function isStepUnlocked(stepNumber) {
        // Nếu AI đang processing, chỉ cho phép step 1 và 2
        if (window.aiProcessingInProgress) {
            return stepNumber === 1 || stepNumber === 2;
        }

        // Step 1: luôn unlock (bước đầu tiên)
        if (stepNumber === 1) {
            return true;
        }

        // Step 2: unlock nếu đã có documents hoặc đã vào step 1
        if (stepNumber === 2) {
            return true; // Có thể vào step 2 để xử lý documents
        }

        // Step 3: unlock nếu:
        // - Đã hoàn thành step 2 (AI processing + FR extraction) HOẶC
        // - Có documents đã completed (bỏ qua step 2)
        if (stepNumber === 3) {
            const hasCompletedDocs = window.hasCompletedDocuments || false;
            const aiComplete = window.aiProcessingComplete || false;
            const frComplete = window.frExtractionComplete || false;
            return hasCompletedDocs || (aiComplete && frComplete);
        }

        // Step 4: unlock nếu đã hoàn thành step 3 (đã chọn và lưu FR)
        if (stepNumber === 4) {
            return window.frSelectionsSaved || false;
        }

        // Step 5: unlock nếu:
        // - Đã hoàn thành step 4 (đã chọn test cases) HOẶC
        // - Có report_id trong URL (đang xem report) HOẶC
        // - Report đã sẵn sàng (testReportReady)
        if (stepNumber === 5) {
            // Check if there's a report_id in URL
            const urlParams = new URLSearchParams(window.location.search);
            const hasReportId = urlParams.has('report_id') || urlParams.has('report_ids');
            
            return window.testCasesSelected || hasReportId || window.testReportReady || false;
        }

        return false;
    }

    // Hàm lấy step cao nhất đã được unlock
    function getMaxUnlockedStep() {
        for (let i = totalSteps; i >= 1; i--) {
            if (isStepUnlocked(i)) {
                return i;
            }
        }
        return 1; // Mặc định step 1 luôn unlock
    }

    // Hàm cập nhật UI để disable/lock các step chưa unlock
    function updateStepLocks() {
        const steps = document.querySelectorAll('.step');
        const maxUnlocked = getMaxUnlockedStep();

        steps.forEach((step, index) => {
            const stepNumber = index + 1;
            const isUnlocked = stepNumber <= maxUnlocked;

            if (isUnlocked) {
                step.classList.remove('locked', 'disabled');
                step.style.cursor = 'pointer';
                step.style.opacity = '1';
            } else {
                step.classList.add('locked', 'disabled');
                step.style.cursor = 'not-allowed';
                step.style.opacity = '0.5';
            }
        });
    }

    // Note: Logic restore step đã được xử lý trong DOMContentLoaded listener ở trên
    // Không cần duplicate logic ở đây nữa

    // AI Processing Functions
    function startAIProcessing(projectUuid) {
        // Set flag that AI processing is in progress
        window.aiProcessingInProgress = true;
        // Block tất cả tương tác trên màn hình
        blockAllInteractions();
        // Cập nhật lock status cho các step
        updateStepLocks();

        // Update UI to show processing
        document.getElementById('aiStatusText').textContent = 'AI Processing Started...';
        document.getElementById('aiStatusMessage').textContent = 'AI is analyzing your document...';

        // Realistic progress stages
        const progressStages = [
            { progress: 5, message: 'Initializing AI processing...', duration: 3000 },
            { progress: 15, message: 'Reading document content...', duration: 2000 },
            { progress: 30, message: 'Analyzing document structure...', duration: 2500 },
            { progress: 45, message: 'Extracting key sections...', duration: 3000 },
            { progress: 60, message: 'Processing API endpoints...', duration: 5000 },
            { progress: 75, message: 'Generating section metadata...', duration: 5000 },
            { progress: 85, message: 'Finalizing analysis...', duration: 2000 },
            { progress: 95, message: 'Almost complete...', duration: 1000 }
        ];

        let currentStage = 0;
        let progressInterval;

        function updateProgress() {
            if (currentStage < progressStages.length) {
                const stage = progressStages[currentStage];
                document.getElementById('aiProgressBar').style.width = stage.progress + '%';
                document.getElementById('aiStatusMessage').textContent = stage.message;

                currentStage++;
                setTimeout(updateProgress, stage.duration);
            } else {
                // Keep at 95% until actual completion
                document.getElementById('aiProgressBar').style.width = '95%';
                document.getElementById('aiStatusMessage').textContent = 'Waiting for completion...';
            }
        }

        // Start the staged progress
        setTimeout(updateProgress, 500);

        fetch(`/project/${projectUuid}/ai/start/`, {
            method: 'POST',
            headers: {
                'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value,
                'Content-Type': 'application/json'
            },
            _noLoading: true,
            _timeoutMs: 60000
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Start checking status
                    checkAIStatusLoop(projectUuid);
                } else {
                    // Stop any ongoing progress updates
                    // Clear processing in progress flag on error
                    window.aiProcessingInProgress = false;
                    // Unblock tất cả tương tác
                    unblockAllInteractions();
                    updateStepLocks();
                    document.getElementById('aiStatusText').textContent = 'Error';
                    document.getElementById('aiStatusMessage').textContent = data.message;
                    document.getElementById('aiStatusIndicator').innerHTML = `
                <div class="alert alert-danger">
                    <i class="bi bi-exclamation-triangle"></i> ${data.message}
                </div>
            `;
                }
            })
            .catch(error => {
                console.error('Error:', error);
                document.getElementById('aiStatusText').textContent = 'Error';
                document.getElementById('aiStatusMessage').textContent = 'An error occurred while starting AI processing.';
                document.getElementById('aiStatusIndicator').innerHTML = `
            <div class="alert alert-danger">
                <i class="bi bi-exclamation-triangle"></i> An error occurred while starting AI processing.
            </div>
        `;
            });
    }

    function checkAIStatusLoop(projectUuid) {
        let checking = false;
        const checkStatus = () => {
            if (checking) return; // prevent overlap
            checking = true;
            fetch(`/project/${projectUuid}/ai/status/`, { _noLoading: true, _timeoutMs: 15000, _retries: 1 })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'completed') {
                        // Gradually complete the progress bar
                        let finalProgress = 95;
                        const finalInterval = setInterval(() => {
                            finalProgress += 1;
                            document.getElementById('aiProgressBar').style.width = finalProgress + '%';
                            if (finalProgress >= 100) {
                                clearInterval(finalInterval);
                                document.getElementById('aiStatusText').textContent = 'AI Processing Completed!';
                                document.getElementById('aiStatusMessage').textContent = 'Document analysis completed successfully.';
                                document.getElementById('aiStatusIndicator').innerHTML = `
                            <div class="alert alert-success">
                                <i class="bi bi-check-circle"></i> Processing completed successfully!
                            </div>
                        `;
                                // Store flag that AI processing is complete
                                window.aiProcessingComplete = true;
                                // Note: Không clear aiProcessingInProgress ở đây vì FR extraction vẫn đang chạy
                                // Chỉ clear khi FR extraction hoàn thành
                                // Cập nhật lock status cho các step
                                updateStepLocks();
                                // Start FR extraction in step 2 instead of redirecting to step 3
                                setTimeout(() => {
                                    extractFRInStep2(projectUuid);
                                }, 1500);
                            }
                        }, 100);
                    } else if (data.status === 'processing') {
                        // Update status message with progress info
                        document.getElementById('aiStatusMessage').textContent = data.message;
                        // Continue checking
                        setTimeout(() => { checking = false; checkStatus(); }, 2000);
                    } else {
                        // Stop progress updates
                        // Clear processing in progress flag on error
                        window.aiProcessingInProgress = false;
                        // Unblock tất cả tương tác
                        unblockAllInteractions();
                        updateStepLocks();
                        document.getElementById('aiStatusText').textContent = 'Error';
                        document.getElementById('aiStatusMessage').textContent = data.message;
                        document.getElementById('aiStatusIndicator').innerHTML = `
                    <div class="alert alert-danger">
                        <i class="bi bi-exclamation-triangle"></i> ${data.message}
                    </div>
                `;
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                    // Clear processing in progress flag on error
                    window.aiProcessingInProgress = false;
                    // Unblock tất cả tương tác
                    unblockAllInteractions();
                    updateStepLocks();
                    document.getElementById('aiStatusText').textContent = 'Error';
                    document.getElementById('aiStatusMessage').textContent = 'An error occurred while checking status.';
                    document.getElementById('aiStatusIndicator').innerHTML = `
                <div class="alert alert-danger">
                    <i class="bi bi-exclamation-triangle"></i> An error occurred while checking status.
                </div>
            `;
                })
                .finally(() => { checking = false; });
        };

        // Start checking after 1 second
        setTimeout(checkStatus, 1000);
    }

    // FR Extraction Functions for Step 2
    function extractFRInStep2(projectUuid) {
        // Đảm bảo flag processing vẫn được giữ (FR extraction là phần của quá trình processing)
        window.aiProcessingInProgress = true;
        // Đảm bảo blocking overlay vẫn hiển thị
        blockAllInteractions();
        // Cập nhật lock status cho các step
        updateStepLocks();

        // Update UI to show FR extraction
        document.getElementById('aiStatusText').textContent = 'Đang trích xuất Functional Requirements...';
        document.getElementById('aiStatusMessage').textContent = 'AI đang phân tích và trích xuất các Functional Requirements từ documents...';
        document.getElementById('aiProgressBar').style.width = '0%';

        // Cập nhật message trong blocking overlay
        const overlayContent = document.querySelector('#ai-processing-blocking-overlay > div');
        if (overlayContent) {
            overlayContent.querySelector('h5').textContent = 'Đang trích xuất Functional Requirements...';
            overlayContent.querySelector('p').textContent = 'AI đang phân tích và trích xuất các Functional Requirements. Vui lòng đợi quá trình hoàn thành.';
        }

        // Realistic progress stages for FR extraction
        const progressStages = [
            { progress: 10, message: 'Đang khởi tạo quá trình trích xuất FR...', duration: 2000 },
            { progress: 25, message: 'Đang phân tích table of contents...', duration: 3000 },
            { progress: 40, message: 'Đang nhóm các Functional Requirements...', duration: 4000 },
            { progress: 55, message: 'Đang xác định FR trùng lặp...', duration: 3000 },
            { progress: 70, message: 'Đang tạo mapping FR với documents...', duration: 4000 },
            { progress: 85, message: 'Đang hoàn thiện FR annotations...', duration: 3000 },
            { progress: 95, message: 'Sắp hoàn thành...', duration: 2000 }
        ];

        let currentStage = 0;

        function updateProgress() {
            if (currentStage < progressStages.length) {
                const stage = progressStages[currentStage];
                document.getElementById('aiProgressBar').style.width = stage.progress + '%';
                document.getElementById('aiStatusMessage').textContent = stage.message;

                currentStage++;
                setTimeout(updateProgress, stage.duration);
            } else {
                // Keep at 95% until actual completion
                document.getElementById('aiProgressBar').style.width = '95%';
                document.getElementById('aiStatusMessage').textContent = 'Đang chờ hoàn thành trích xuất FR...';
            }
        }

        // Start the staged progress
        setTimeout(updateProgress, 500);

        // Call the backend API endpoint with analyze=true
        const apiUrl = `/project/${projectUuid}/annotate-fr/`;

        console.log('Extracting FR in step 2 with analyze=true');

        fetch(apiUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value,
                'accept': 'application/json'
            },
            body: JSON.stringify({
                lang: 'vi',
                analyze: true  // Always use analyze=true in step 2
            }),
            _noLoading: true,
            _timeoutMs: 60000,
            _retries: 1
        })
            .then(response => {
                console.log('FR extraction API response status:', response.status);
                return response.json();
            })
            .then(data => {
                console.log('FR extraction API response data:', data);

                if (data.success) {
                    // Gradually complete the progress bar
                    let finalProgress = 95;
                    const finalInterval = setInterval(() => {
                        finalProgress += 1;
                        document.getElementById('aiProgressBar').style.width = finalProgress + '%';
                        if (finalProgress >= 100) {
                            clearInterval(finalInterval);
                            document.getElementById('aiStatusText').textContent = 'FR Extraction Completed!';
                            document.getElementById('aiStatusMessage').textContent = `Đã trích xuất thành công ${data.count || 0} Functional Requirements.`;
                            document.getElementById('aiStatusIndicator').innerHTML = `
                        <div class="alert alert-success">
                            <i class="bi bi-check-circle"></i> FR extraction completed successfully!
                        </div>
                    `;

                            // Store flag that FR extraction is complete
                            window.frExtractionComplete = true;
                            // Clear processing in progress flag (AI processing và FR extraction đã hoàn thành)
                            window.aiProcessingInProgress = false;
                            // Unblock tất cả tương tác
                            unblockAllInteractions();
                            // Cập nhật lock status cho các step
                            updateStepLocks();

                            // Auto navigate to step 3 without fresh_analysis parameter
                            // Lưu step 3 vào localStorage trước khi redirect
                            localStorage.setItem(`project_step_${projectUuid}`, '3');
                            setTimeout(() => {
                                window.location.href = `/project/{{ project.uuid }}/?step=3`;
                            }, 2000);
                        }
                    }, 100);
                } else {
                    // Error handling
                    // Clear processing in progress flag on error
                    window.aiProcessingInProgress = false;
                    // Unblock tất cả tương tác
                    unblockAllInteractions();
                    updateStepLocks();
                    document.getElementById('aiStatusText').textContent = 'FR Extraction Error';
                    document.getElementById('aiStatusMessage').textContent = data.message || 'Error extracting Functional Requirements.';
                    document.getElementById('aiStatusIndicator').innerHTML = `
                <div class="alert alert-danger">
                    <i class="bi bi-exclamation-triangle"></i> ${data.message || 'Error extracting Functional Requirements.'}
                </div>
            `;
                }
            })
            .catch(error => {
                console.error('Error extracting FR:', error);
                // Clear processing in progress flag on error
                window.aiProcessingInProgress = false;
                // Unblock tất cả tương tác
                unblockAllInteractions();
                updateStepLocks();
                document.getElementById('aiStatusText').textContent = 'FR Extraction Error';
                document.getElementById('aiStatusMessage').textContent = 'An error occurred while extracting Functional Requirements.';
                document.getElementById('aiStatusIndicator').innerHTML = `
            <div class="alert alert-danger">
                <i class="bi bi-exclamation-triangle"></i> Failed to extract Functional Requirements: ${error.message}
            </div>
        `;
            });
    }

    // Test Case Generation Functions
    // Store progress interval references to prevent overlap
    let testCaseFinalInterval = null;
    let testCaseStatusCheckTimeout = null;
    let testCaseProgressStages = []; // Store all stage timeouts
    let isTestCaseProgressRunning = false; // Flag to prevent multiple progress bars
    let isTestCaseGenerationStarted = false; // Flag to prevent multiple calls to startTestCaseGeneration
    
    // Retry configuration for test case generation
    let testCaseGenerateRetryCount = 0;
    const MAX_GENERATE_RETRIES = 5;
    const INITIAL_RETRY_DELAY = 3000; // 3 seconds
    
    let testCaseStatusRetryCount = 0;
    const MAX_STATUS_RETRIES = 10;
    
    // Helper function for retry with exponential backoff
    function retryWithBackoff(fn, maxRetries, initialDelay, retryCount = 0) {
        return fn().catch(error => {
            if (retryCount < maxRetries) {
                const delay = initialDelay * Math.pow(2, retryCount); // Exponential backoff
                console.log(`Retry attempt ${retryCount + 1}/${maxRetries} after ${delay}ms...`);
                return new Promise(resolve => {
                    setTimeout(() => {
                        resolve(retryWithBackoff(fn, maxRetries, initialDelay, retryCount + 1));
                    }, delay);
                });
            }
            throw error; // Re-throw if max retries reached
        });
    }

    function clearAllTestCaseProgress() {
        // Clear all progress-related timeouts and intervals
        if (testCaseFinalInterval) {
            clearInterval(testCaseFinalInterval);
            testCaseFinalInterval = null;
        }
        if (testCaseStatusCheckTimeout) {
            clearTimeout(testCaseStatusCheckTimeout);
            testCaseStatusCheckTimeout = null;
        }
        // Clear all stage timeouts and intervals
        testCaseProgressStages.forEach(id => {
            if (id) {
                clearTimeout(id);
                clearInterval(id);
            }
        });
        testCaseProgressStages = [];
        // Clear countdown interval
        if (window.testCaseCountdownInterval) {
            clearInterval(window.testCaseCountdownInterval);
            window.testCaseCountdownInterval = null;
        }
        isTestCaseProgressRunning = false;
    }

    function startTestCaseGeneration(projectUuid) {
        // Prevent multiple calls to this function
        if (isTestCaseGenerationStarted) {
            console.log('Test case generation already started, skipping duplicate call...');
            return;
        }

        // Clear any existing progress first
        clearAllTestCaseProgress();

        // Set flag to prevent duplicate calls
        isTestCaseGenerationStarted = true;

        // First, check if testsuite already exists (with retry)
        const checkTestSuite = () => {
            return fetch(`/project/${projectUuid}/test-cases/check/`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
                },
                _noLoading: true
                // Removed timeout - allow more time for check
            })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                });
        };
        
        // Retry check with exponential backoff (max 3 retries for check)
        retryWithBackoff(checkTestSuite, 3, 2000)
            .then(data => {
                if (data.success && data.exists) {
                    // Test suite already exists, just load the test cases
                    // Reset flag since we're loading existing test cases, not generating new ones
                    isTestCaseGenerationStarted = false;
                    document.getElementById('testCaseStatusText').textContent = 'Đang tải Test Cases...';
                    document.getElementById('testCaseStatusMessage').textContent = `Đang tải ${data.test_cases_count} test cases đã có sẵn...`;
                    document.getElementById('testCaseProgressBar').style.width = '100%';

                    // Load test cases directly
                    setTimeout(() => {
                        fetchTestCases(projectUuid);
                    }, 500);
                } else {
                    // No test suite exists, trigger generation as before
                    // Reset UI to show processing
                    document.getElementById('testCaseProcessingContainer').style.display = 'block';
                    document.getElementById('testCaseResultsContainer').style.display = 'none';
                    document.getElementById('testCaseStatusText').textContent = 'Đang bắt đầu tạo Test Cases...';
                    document.getElementById('testCaseStatusMessage').textContent = 'AI đang tạo test cases từ các sections đã chọn...';
                    document.getElementById('testCaseProgressBar').style.width = '0%';

                    // Prevent multiple progress bars from running
                    if (isTestCaseProgressRunning) {
                        console.log('Test case progress already running, skipping...');
                        return;
                    }

                    isTestCaseProgressRunning = true;

                    // Countdown timer 60 seconds - store reference globally so it can be cleared
                    let countdown = 60;
                    let countdownInterval = setInterval(() => {
                        if (!isTestCaseProgressRunning) {
                            clearInterval(countdownInterval);
                            countdownInterval = null;
                            return;
                        }

                        countdown--;
                        const progress = Math.min(95, ((60 - countdown) / 60) * 95);
                        document.getElementById('testCaseProgressBar').style.width = progress + '%';
                        document.getElementById('testCaseStatusMessage').textContent = `Đang tạo test cases... Còn lại ${countdown} giây`;

                        if (countdown <= 0) {
                            clearInterval(countdownInterval);
                            countdownInterval = null;
                            document.getElementById('testCaseProgressBar').style.width = '95%';
                            document.getElementById('testCaseStatusMessage').textContent = 'Đang chờ hoàn thành...';
                        }
                    }, 1000);
                    // Store interval reference so it can be cleared by checkTestCaseStatusLoop
                    window.testCaseCountdownInterval = countdownInterval;
                    testCaseProgressStages.push(countdownInterval);

                    // Reset retry count for new generation attempt
                    testCaseGenerateRetryCount = 0;
                    
                    // Function to call generate API with retry
                    const generateTestCases = () => {
                        return fetch(`/project/${projectUuid}/test-cases/generate/`, {
                            method: 'POST',
                            headers: {
                                'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value,
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                lang: 'en'
                            }),
                            _noLoading: true
                            // Removed timeout - let BE handle retry timing
                        })
                            .then(response => {
                                if (!response.ok) {
                                    throw new Error(`HTTP error! status: ${response.status}`);
                                }
                                return response.json();
                            });
                    };
                    
                    // Retry with exponential backoff
                    retryWithBackoff(generateTestCases, MAX_GENERATE_RETRIES, INITIAL_RETRY_DELAY)
                        .then(data => {
                            if (data.success) {
                                // Reset retry count on success
                                testCaseGenerateRetryCount = 0;
                                // Stop the countdown immediately when starting status check
                                if (window.testCaseCountdownInterval) {
                                    clearInterval(window.testCaseCountdownInterval);
                                    window.testCaseCountdownInterval = null;
                                }
                                // Update UI to show we're now checking status (not countdown)
                                document.getElementById('testCaseProgressBar').style.width = '50%';
                                document.getElementById('testCaseStatusMessage').textContent = 'Đang xử lý...';
                                // Start checking status
                                checkTestCaseStatusLoop(projectUuid);
                            } else {
                                // If backend returns error but not network error, check if we should retry
                                if (testCaseGenerateRetryCount < MAX_GENERATE_RETRIES) {
                                    testCaseGenerateRetryCount++;
                                    const delay = INITIAL_RETRY_DELAY * Math.pow(2, testCaseGenerateRetryCount - 1);
                                    document.getElementById('testCaseStatusMessage').textContent = `Lỗi: ${data.message}. Đang thử lại sau ${delay/1000} giây... (Lần thử: ${testCaseGenerateRetryCount}/${MAX_GENERATE_RETRIES})`;
                                    console.log(`Retrying generate after error: ${data.message}`);
                                    setTimeout(() => {
                                        retryWithBackoff(generateTestCases, MAX_GENERATE_RETRIES - testCaseGenerateRetryCount, INITIAL_RETRY_DELAY)
                                            .then(data => {
                                                if (data.success) {
                                                    testCaseGenerateRetryCount = 0;
                                                    if (window.testCaseCountdownInterval) {
                                                        clearInterval(window.testCaseCountdownInterval);
                                                        window.testCaseCountdownInterval = null;
                                                    }
                                                    document.getElementById('testCaseProgressBar').style.width = '50%';
                                                    document.getElementById('testCaseStatusMessage').textContent = 'Đang xử lý...';
                                                    checkTestCaseStatusLoop(projectUuid);
                                                } else {
                                                    // Max retries reached or non-retryable error
                                                    handleGenerateError(data.message);
                                                }
                                            })
                                            .catch(error => {
                                                handleGenerateError(error.message);
                                            });
                                    }, delay);
                                } else {
                                    // Max retries reached
                                    handleGenerateError(data.message);
                                }
                            }
                        })
                        .catch(error => {
                            console.error('Error generating test cases:', error);
                            if (testCaseGenerateRetryCount < MAX_GENERATE_RETRIES) {
                                testCaseGenerateRetryCount++;
                                const delay = INITIAL_RETRY_DELAY * Math.pow(2, testCaseGenerateRetryCount - 1);
                                document.getElementById('testCaseStatusMessage').textContent = `Lỗi kết nối. Đang thử lại sau ${delay/1000} giây... (Lần thử: ${testCaseGenerateRetryCount}/${MAX_GENERATE_RETRIES})`;
                                console.log(`Retrying generate after network error, attempt ${testCaseGenerateRetryCount}`);
                                setTimeout(() => {
                                    retryWithBackoff(generateTestCases, MAX_GENERATE_RETRIES - testCaseGenerateRetryCount, INITIAL_RETRY_DELAY)
                                        .then(data => {
                                            if (data.success) {
                                                testCaseGenerateRetryCount = 0;
                                                if (window.testCaseCountdownInterval) {
                                                    clearInterval(window.testCaseCountdownInterval);
                                                    window.testCaseCountdownInterval = null;
                                                }
                                                document.getElementById('testCaseProgressBar').style.width = '50%';
                                                document.getElementById('testCaseStatusMessage').textContent = 'Đang xử lý...';
                                                checkTestCaseStatusLoop(projectUuid);
                                            } else {
                                                handleGenerateError(data.message);
                                            }
                                        })
                                        .catch(err => {
                                            handleGenerateError(err.message);
                                        });
                                }, delay);
                            } else {
                                handleGenerateError(error.message || 'An error occurred while starting test case generation.');
                            }
                        });
                    
                    // Helper function to handle generate errors
                    function handleGenerateError(errorMessage) {
                        isTestCaseProgressRunning = false;
                        clearAllTestCaseProgress();
                        isTestCaseGenerationStarted = false;
                        testCaseGenerateRetryCount = 0;
                        document.getElementById('testCaseStatusText').textContent = 'Lỗi';
                        document.getElementById('testCaseStatusMessage').textContent = errorMessage || 'Không thể khởi động tạo test cases sau nhiều lần thử.';
                        document.getElementById('testCaseStatusIndicator').innerHTML = `
                            <div class="alert alert-danger">
                                <i class="bi bi-exclamation-triangle"></i> ${errorMessage || 'Không thể khởi động tạo test cases sau nhiều lần thử.'}
                            </div>
                        `;
                    }
                }
            })
            .catch(error => {
                console.error('Error checking test suite after retries:', error);
                // Clear any existing progress before starting new one
                clearAllTestCaseProgress();
                // Reset flag so we can retry
                isTestCaseGenerationStarted = false;
                // If check fails after retries, proceed with generation as fallback
                document.getElementById('testCaseStatusText').textContent = 'Đang bắt đầu tạo Test Cases...';
                document.getElementById('testCaseStatusMessage').textContent = 'Không thể kiểm tra test suite hiện có. Đang bắt đầu tạo mới...';
                document.getElementById('testCaseProgressBar').style.width = '0%';

                // Set flag again for the fallback generation
                isTestCaseGenerationStarted = true;
                testCaseGenerateRetryCount = 0;

                // Function to call generate API with retry (fallback)
                const generateTestCasesFallback = () => {
                    return fetch(`/project/${projectUuid}/test-cases/generate/`, {
                        method: 'POST',
                        headers: {
                            'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            lang: 'en'
                        }),
                        _noLoading: true
                        // Removed timeout - let BE handle retry timing
                    })
                        .then(response => {
                            if (!response.ok) {
                                throw new Error(`HTTP error! status: ${response.status}`);
                            }
                            return response.json();
                        });
                };
                
                // Retry with exponential backoff for fallback
                retryWithBackoff(generateTestCasesFallback, MAX_GENERATE_RETRIES, INITIAL_RETRY_DELAY)
                    .then(data => {
                        if (data.success) {
                            testCaseGenerateRetryCount = 0;
                            // Stop any countdown immediately when starting status check
                            if (window.testCaseCountdownInterval) {
                                clearInterval(window.testCaseCountdownInterval);
                                window.testCaseCountdownInterval = null;
                            }
                            // Update UI to show we're now checking status
                            document.getElementById('testCaseProgressBar').style.width = '50%';
                            document.getElementById('testCaseStatusMessage').textContent = 'Đang xử lý...';
                            checkTestCaseStatusLoop(projectUuid);
                        } else {
                            if (testCaseGenerateRetryCount < MAX_GENERATE_RETRIES) {
                                testCaseGenerateRetryCount++;
                                const delay = INITIAL_RETRY_DELAY * Math.pow(2, testCaseGenerateRetryCount - 1);
                                document.getElementById('testCaseStatusMessage').textContent = `Lỗi: ${data.message}. Đang thử lại sau ${delay/1000} giây... (Lần thử: ${testCaseGenerateRetryCount}/${MAX_GENERATE_RETRIES})`;
                                setTimeout(() => {
                                    retryWithBackoff(generateTestCasesFallback, MAX_GENERATE_RETRIES - testCaseGenerateRetryCount, INITIAL_RETRY_DELAY)
                                        .then(data => {
                                            if (data.success) {
                                                testCaseGenerateRetryCount = 0;
                                                if (window.testCaseCountdownInterval) {
                                                    clearInterval(window.testCaseCountdownInterval);
                                                    window.testCaseCountdownInterval = null;
                                                }
                                                document.getElementById('testCaseProgressBar').style.width = '50%';
                                                document.getElementById('testCaseStatusMessage').textContent = 'Đang xử lý...';
                                                checkTestCaseStatusLoop(projectUuid);
                                            } else {
                                                isTestCaseProgressRunning = false;
                                                clearAllTestCaseProgress();
                                                isTestCaseGenerationStarted = false;
                                                testCaseGenerateRetryCount = 0;
                                                document.getElementById('testCaseStatusText').textContent = 'Lỗi';
                                                document.getElementById('testCaseStatusMessage').textContent = data.message || 'Không thể khởi động tạo test cases.';
                                            }
                                        })
                                        .catch(err => {
                                            isTestCaseProgressRunning = false;
                                            clearAllTestCaseProgress();
                                            isTestCaseGenerationStarted = false;
                                            testCaseGenerateRetryCount = 0;
                                            document.getElementById('testCaseStatusText').textContent = 'Lỗi';
                                            document.getElementById('testCaseStatusMessage').textContent = err.message || 'Không thể khởi động tạo test cases sau nhiều lần thử.';
                                        });
                                }, delay);
                            } else {
                                isTestCaseProgressRunning = false;
                                clearAllTestCaseProgress();
                                isTestCaseGenerationStarted = false;
                                testCaseGenerateRetryCount = 0;
                                document.getElementById('testCaseStatusText').textContent = 'Lỗi';
                                document.getElementById('testCaseStatusMessage').textContent = data.message || 'Không thể khởi động tạo test cases sau nhiều lần thử.';
                            }
                        }
                    })
                    .catch(err => {
                        console.error('Error generating test cases:', err);
                        if (testCaseGenerateRetryCount < MAX_GENERATE_RETRIES) {
                            testCaseGenerateRetryCount++;
                            const delay = INITIAL_RETRY_DELAY * Math.pow(2, testCaseGenerateRetryCount - 1);
                            document.getElementById('testCaseStatusMessage').textContent = `Lỗi kết nối. Đang thử lại sau ${delay/1000} giây... (Lần thử: ${testCaseGenerateRetryCount}/${MAX_GENERATE_RETRIES})`;
                            setTimeout(() => {
                                retryWithBackoff(generateTestCasesFallback, MAX_GENERATE_RETRIES - testCaseGenerateRetryCount, INITIAL_RETRY_DELAY)
                                    .then(data => {
                                        if (data.success) {
                                            testCaseGenerateRetryCount = 0;
                                            if (window.testCaseCountdownInterval) {
                                                clearInterval(window.testCaseCountdownInterval);
                                                window.testCaseCountdownInterval = null;
                                            }
                                            document.getElementById('testCaseProgressBar').style.width = '50%';
                                            document.getElementById('testCaseStatusMessage').textContent = 'Đang xử lý...';
                                            checkTestCaseStatusLoop(projectUuid);
                                        } else {
                                            isTestCaseProgressRunning = false;
                                            clearAllTestCaseProgress();
                                            isTestCaseGenerationStarted = false;
                                            testCaseGenerateRetryCount = 0;
                                            document.getElementById('testCaseStatusText').textContent = 'Lỗi';
                                            document.getElementById('testCaseStatusMessage').textContent = data.message || 'Không thể khởi động tạo test cases.';
                                        }
                                    })
                                    .catch(error => {
                                        isTestCaseProgressRunning = false;
                                        clearAllTestCaseProgress();
                                        isTestCaseGenerationStarted = false;
                                        testCaseGenerateRetryCount = 0;
                                        document.getElementById('testCaseStatusText').textContent = 'Lỗi';
                                        document.getElementById('testCaseStatusMessage').textContent = error.message || 'Không thể khởi động tạo test cases sau nhiều lần thử.';
                                    });
                            }, delay);
                        } else {
                            isTestCaseProgressRunning = false;
                            clearAllTestCaseProgress();
                            isTestCaseGenerationStarted = false;
                            testCaseGenerateRetryCount = 0;
                            document.getElementById('testCaseStatusText').textContent = 'Lỗi';
                            document.getElementById('testCaseStatusMessage').textContent = err.message || 'Không thể khởi động tạo test cases sau nhiều lần thử.';
                        }
                    });
            });
    }

    function checkTestCaseStatusLoop(projectUuid) {
        // Clear staged progress (but keep the flag running since we're checking status)
        // Clear both timeouts and intervals
        testCaseProgressStages.forEach(id => {
            if (id) {
                clearTimeout(id);
                clearInterval(id);
            }
        });
        testCaseProgressStages = [];

        // Also clear the countdown interval if it exists
        if (window.testCaseCountdownInterval) {
            clearInterval(window.testCaseCountdownInterval);
            window.testCaseCountdownInterval = null;
        }

        // Clear status check timeout if exists
        if (testCaseStatusCheckTimeout) {
            clearTimeout(testCaseStatusCheckTimeout);
            testCaseStatusCheckTimeout = null;
        }

        let checking = false;
        testCaseStatusRetryCount = 0; // Reset retry count when starting new status check loop
        
        const checkStatus = () => {
            if (checking) return; // prevent overlap
            checking = true;
            
            // Function to fetch status with retry capability
            const fetchStatus = () => {
                return fetch(`/project/${projectUuid}/test-cases/status/`, { 
                    _noLoading: true
                    // Removed timeout - let BE handle retry timing
                })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        return response.json();
                    });
            };
            
            fetchStatus()
                .then(data => {
                    // Reset retry count on successful response
                    testCaseStatusRetryCount = 0;
                    
                    if (data.status === 'completed') {
                        // Stop staged progress
                        isTestCaseProgressRunning = false;

                        // Clear any existing final interval
                        if (testCaseFinalInterval) {
                            clearInterval(testCaseFinalInterval);
                            testCaseFinalInterval = null;
                        }

                        // Gradually complete the progress bar from 95% to 100%
                        let finalProgress = 95;
                        testCaseFinalInterval = setInterval(() => {
                            finalProgress += 1;
                            document.getElementById('testCaseProgressBar').style.width = finalProgress + '%';
                            if (finalProgress >= 100) {
                                clearInterval(testCaseFinalInterval);
                                testCaseFinalInterval = null;
                                document.getElementById('testCaseStatusText').textContent = 'Hoàn thành tạo Test Cases!';
                                document.getElementById('testCaseStatusMessage').textContent = 'Test cases đã được tạo thành công.';
                                document.getElementById('testCaseStatusIndicator').innerHTML = `
                            <div class="alert alert-success">
                                <i class="bi bi-check-circle"></i> Tạo test cases hoàn thành thành công!
                            </div>
                        `;
                                // Fetch test cases after completion
                                // Reset flag since generation is complete
                                isTestCaseGenerationStarted = false;
                                setTimeout(() => {
                                    fetchTestCases(projectUuid);
                                }, 1000);
                            }
                        }, 50);
                    } else if (data.status === 'processing') {
                        // Update status message with progress info from backend
                        document.getElementById('testCaseStatusMessage').textContent = data.message;
                        // Update progress bar if backend provides progress value
                        if (data.progress !== undefined) {
                            document.getElementById('testCaseProgressBar').style.width = data.progress + '%';
                        }
                        // Continue checking - use 5 seconds after 1 minute wait
                        // Check message to determine polling interval
                        const pollingInterval = data.message && data.message.includes('polling') ? 5000 : 2000;
                        testCaseStatusCheckTimeout = setTimeout(() => { checking = false; checkStatus(); }, pollingInterval);
                    } else {
                        // If status is error but not fatal, retry a few times
                        if (testCaseStatusRetryCount < MAX_STATUS_RETRIES && 
                            (data.message && (data.message.includes('retry') || data.message.includes('thử lại') || data.message.includes('processing')))) {
                            testCaseStatusRetryCount++;
                            const delay = 5000; // 5 seconds for status retry
                            document.getElementById('testCaseStatusMessage').textContent = `${data.message} (Đang thử lại sau ${delay/1000} giây... Lần thử: ${testCaseStatusRetryCount}/${MAX_STATUS_RETRIES})`;
                            console.log(`Retrying status check after error: ${data.message}, attempt ${testCaseStatusRetryCount}`);
                            testCaseStatusCheckTimeout = setTimeout(() => { checking = false; checkStatus(); }, delay);
                        } else {
                            // Stop all progress updates - max retries reached or fatal error
                            isTestCaseProgressRunning = false;
                            clearAllTestCaseProgress();
                            isTestCaseGenerationStarted = false; // Reset flag on error
                            testCaseStatusRetryCount = 0;
                            document.getElementById('testCaseStatusText').textContent = 'Lỗi';
                            document.getElementById('testCaseStatusMessage').textContent = data.message || 'Có lỗi xảy ra khi kiểm tra trạng thái.';
                            document.getElementById('testCaseStatusIndicator').innerHTML = `
                        <div class="alert alert-danger">
                            <i class="bi bi-exclamation-triangle"></i> ${data.message || 'Có lỗi xảy ra khi kiểm tra trạng thái.'}
                        </div>
                    `;
                        }
                    }
                })
                .catch(error => {
                    console.error('Error checking status:', error);
                    
                    // Retry on network errors
                    if (testCaseStatusRetryCount < MAX_STATUS_RETRIES) {
                        testCaseStatusRetryCount++;
                        const delay = 5000; // 5 seconds for status retry
                        document.getElementById('testCaseStatusMessage').textContent = `Lỗi kết nối khi kiểm tra trạng thái. Đang thử lại sau ${delay/1000} giây... (Lần thử: ${testCaseStatusRetryCount}/${MAX_STATUS_RETRIES})`;
                        console.log(`Retrying status check after network error, attempt ${testCaseStatusRetryCount}`);
                        testCaseStatusCheckTimeout = setTimeout(() => { checking = false; checkStatus(); }, delay);
                    } else {
                        // Max retries reached
                        isTestCaseProgressRunning = false;
                        clearAllTestCaseProgress();
                        isTestCaseGenerationStarted = false; // Reset flag on error
                        testCaseStatusRetryCount = 0;
                        document.getElementById('testCaseStatusText').textContent = 'Lỗi';
                        document.getElementById('testCaseStatusMessage').textContent = 'Không thể kiểm tra trạng thái sau nhiều lần thử. Vui lòng làm mới trang.';
                        document.getElementById('testCaseStatusIndicator').innerHTML = `
                    <div class="alert alert-danger">
                        <i class="bi bi-exclamation-triangle"></i> Không thể kiểm tra trạng thái sau nhiều lần thử. Vui lòng làm mới trang.
                    </div>
                `;
                    }
                })
                .finally(() => { checking = false; });
        };

        // Start checking after 1 second
        testCaseStatusCheckTimeout = setTimeout(checkStatus, 1000);
    }

    function fetchTestCases(projectUuid) {
        // Fetch test cases from API
        fetch(`/project/${projectUuid}/test-cases/`, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
            },
            _timeoutMs: 30000,
            _retries: 1
        })
            .then(response => response.json())
            .then(data => {
                if (data.success && data.data) {
                    // Handle dataframe format: data.data.rows contains array of test cases
                    const testCases = data.data.rows || [];
                    displayTestCases(testCases);
                } else {
                    console.error('Error fetching test cases:', data.message);
                    displayTestCases([]);
                    showNotification('error', 'Lỗi!', data.message || 'Không thể tải test cases.');
                }
            })
            .catch(error => {
                console.error('Error fetching test cases:', error);
                displayTestCases([]);
                showNotification('error', 'Lỗi!', 'Không thể tải test cases từ server.');
            });
    }

    // Store test cases globally for detail view
    let allTestCases = [];
    let filteredTestCases = []; // Store filtered test cases
    let currentTestCasesPage = 1;
    const TEST_CASES_PER_PAGE = 7;
    // Store selected test case IDs globally (across all pages)
    let selectedTestCasesSet = new Set();
    let currentEndpointFilter = ''; // Store current endpoint filter
    let currentTestSuiteFilter = ''; // Store current test suite filter

    // Helper function to get test case ID from test case object
    function getTestCaseId(testCase) {
        return (testCase.full_test_case_data && testCase.full_test_case_data.id)
            ? testCase.full_test_case_data.id
            : (testCase.uuid || '');
    }

    function displayTestCases(testCases) {
        // Hide processing container and show results
        document.getElementById('testCaseProcessingContainer').style.display = 'none';
        document.getElementById('testCaseResultsContainer').style.display = 'block';

        // Store test cases globally
        allTestCases = testCases || [];

        // Initialize selectedTestCasesSet with test cases that are already selected in database
        selectedTestCasesSet.clear();
        allTestCases.forEach(tc => {
            if (tc.is_selected === true) {
                const testCaseId = getTestCaseId(tc);
                if (testCaseId) {
                    selectedTestCasesSet.add(testCaseId);
                }
            }
        });

        // Check if any test cases are selected (from database)
        const hasSelectedTestCases = selectedTestCasesSet.size > 0;
        if (hasSelectedTestCases) {
            window.testCasesSelected = true;
            // Cập nhật lock status cho các step
            updateStepLocks();
            // Hiển thị lại nút Next và Back nếu đang ở step 4
            if (currentStep === 4) {
                updateNavigationButtons(4);
            }
        }

        // Reset to first page
        currentTestCasesPage = 1;

        // Populate filter dropdowns
        populateEndpointFilter();
        populateTestSuiteFilter();

        // Initialize filtered test cases with all test cases
        filteredTestCases = allTestCases;
        currentEndpointFilter = '';
        currentTestSuiteFilter = '';

        // Render table with pagination
        renderTestCasesPage();
    }

    // Populate test suite filter dropdown with unique test suite names
    function populateTestSuiteFilter() {
        const testSuiteFilter = document.getElementById('testSuiteFilter');
        if (!testSuiteFilter) return;

        // Get unique test suite names from all test cases
        const testSuites = new Map(); // Use Map to store suite name -> count
        allTestCases.forEach(testCase => {
            const suiteName = testCase.test_suite_name || 'N/A';
            if (suiteName && suiteName !== 'N/A') {
                if (testSuites.has(suiteName)) {
                    testSuites.set(suiteName, testSuites.get(suiteName) + 1);
                } else {
                    testSuites.set(suiteName, 1);
                }
            }
        });

        // Clear existing options except the first one
        testSuiteFilter.innerHTML = '<option value="">Tất cả Test Suites</option>';

        // Add test suite options with count
        const sortedSuites = Array.from(testSuites.entries()).sort((a, b) => a[0].localeCompare(b[0]));
        sortedSuites.forEach(([suiteName, count]) => {
            const option = document.createElement('option');
            option.value = suiteName;
            // Display suite name with count
            const displayText = `${suiteName} (${count} test cases)`;
            option.textContent = displayText;
            option.title = suiteName; // Full suite name in tooltip
            testSuiteFilter.appendChild(option);
        });
    }

    // Populate endpoint filter dropdown with unique endpoints
    function populateEndpointFilter() {
        const endpointFilter = document.getElementById('endpointFilter');
        if (!endpointFilter) return;

        // Get unique endpoints from filtered test cases (or all if no suite filter)
        const sourceTestCases = currentTestSuiteFilter ? filteredTestCases : allTestCases;
        const endpoints = new Set();
        sourceTestCases.forEach(testCase => {
            const endpoint = testCase.endpoint || testCase.api_info?.url || 'N/A';
            if (endpoint && endpoint !== 'N/A') {
                endpoints.add(endpoint);
            }
        });

        // Clear existing options except the first one
        endpointFilter.innerHTML = '<option value="">Tất cả Endpoints</option>';

        // Add endpoint options
        const sortedEndpoints = Array.from(endpoints).sort();
        sortedEndpoints.forEach(endpoint => {
            const option = document.createElement('option');
            option.value = endpoint;
            // Truncate long endpoints for display
            const displayText = endpoint.length > 60 ? endpoint.substring(0, 60) + '...' : endpoint;
            option.textContent = displayText;
            option.title = endpoint; // Full endpoint in tooltip
            endpointFilter.appendChild(option);
        });
    }

    // Filter test cases by test suite
    function filterTestCasesBySuite(testSuiteName) {
        currentTestSuiteFilter = testSuiteName || '';
        
        // Apply filters (both suite and endpoint)
        applyFilters();
    }

    // Filter test cases by endpoint
    function filterTestCasesByEndpoint(endpoint) {
        currentEndpointFilter = endpoint || '';
        
        // Apply filters (both suite and endpoint)
        applyFilters();
    }

    // Apply both filters (test suite and endpoint)
    function applyFilters() {
        // Start with all test cases
        let filtered = allTestCases;

        // Filter by test suite if selected
        if (currentTestSuiteFilter && currentTestSuiteFilter !== '') {
            filtered = filtered.filter(testCase => {
                const suiteName = testCase.test_suite_name || 'N/A';
                return suiteName === currentTestSuiteFilter;
            });
        }

        // Filter by endpoint if selected
        if (currentEndpointFilter && currentEndpointFilter !== '') {
            filtered = filtered.filter(testCase => {
                const testCaseEndpoint = testCase.endpoint || testCase.api_info?.url || 'N/A';
                return testCaseEndpoint === currentEndpointFilter;
            });
        }

        // Update filtered test cases
        filteredTestCases = filtered;

        // Update endpoint filter dropdown based on current suite filter
        if (currentTestSuiteFilter && currentTestSuiteFilter !== '') {
            populateEndpointFilter();
            // Restore endpoint filter selection if it still exists in filtered list
            const endpointFilter = document.getElementById('endpointFilter');
            if (endpointFilter && currentEndpointFilter) {
                // Check if current endpoint filter is still valid
                const validEndpoints = Array.from(endpointFilter.options).map(opt => opt.value);
                if (!validEndpoints.includes(currentEndpointFilter)) {
                    // Current endpoint filter is not valid for this suite, clear it
                    currentEndpointFilter = '';
                    endpointFilter.value = '';
                } else {
                    endpointFilter.value = currentEndpointFilter;
                }
            }
        }

        // Show/hide filtered count badge
        const filteredCountEl = document.getElementById('filteredCount');
        const totalCountEl = document.getElementById('totalCount');
        const filteredCountBadge = document.getElementById('filteredTestCasesCount');
        
        if ((currentTestSuiteFilter && currentTestSuiteFilter !== '') || 
            (currentEndpointFilter && currentEndpointFilter !== '')) {
            if (filteredCountEl && totalCountEl && filteredCountBadge) {
                filteredCountEl.textContent = filteredTestCases.length;
                totalCountEl.textContent = allTestCases.length;
                filteredCountBadge.style.display = 'inline-block';
            }
        } else {
            if (filteredCountBadge) {
                filteredCountBadge.style.display = 'none';
            }
        }

        // Reset to first page when filter changes
        currentTestCasesPage = 1;

        // Re-render table with filtered test cases
        renderTestCasesPage();
    }

    function renderTestCasesPage() {
        const tbody = document.getElementById('testCasesTableBody');
        tbody.innerHTML = '';

        // Use filtered test cases instead of all test cases
        const testCasesToRender = filteredTestCases.length > 0 ? filteredTestCases : allTestCases;

        if (!testCasesToRender || testCasesToRender.length === 0) {
            tbody.innerHTML = `
            <tr>
                <td colspan="6" class="text-center text-muted py-4">
                    <i class="bi bi-inbox" style="font-size: 2rem;"></i><br>
                    Không có test cases nào được tạo.
                </td>
            </tr>
        `;
            document.getElementById('testCasesCount').innerHTML = '<i class="bi bi-info-circle"></i> Tổng: <strong>0</strong> test cases';
            document.getElementById('testCasesPaginationList').innerHTML = '';
            updateSelectedTestCasesCount();
            return;
        }

        // Calculate pagination using filtered test cases
        const totalPages = Math.ceil(testCasesToRender.length / TEST_CASES_PER_PAGE);
        const startIndex = (currentTestCasesPage - 1) * TEST_CASES_PER_PAGE;
        const endIndex = Math.min(startIndex + TEST_CASES_PER_PAGE, testCasesToRender.length);
        const currentPageTestCases = testCasesToRender.slice(startIndex, endIndex);

        // Render current page test cases
        currentPageTestCases.forEach((testCase, localIndex) => {
            const row = document.createElement('tr');
            const globalIndex = startIndex + localIndex;

            // Get category badge color
            const category = testCase.test_category || 'N/A';
            const categoryClass = category === 'Basic Validation' ? 'bg-primary' :
                category === 'Business Logic' ? 'bg-success' : 'bg-secondary';

            // Get status code badge color
            const statusCode = testCase.expected_statuscode || 'N/A';
            const statusClass = statusCode === 200 ? 'bg-success' :
                statusCode >= 400 && statusCode < 500 ? 'bg-warning' :
                    statusCode >= 500 ? 'bg-danger' : 'bg-secondary';

            // Truncate test case name if too long
            const testCaseName = testCase.test_case_name || 'N/A';
            const shortName = testCaseName.length > 80 ? testCaseName.substring(0, 80) + '...' : testCaseName;

            // Truncate endpoint if too long
            const endpoint = testCase.endpoint || 'N/A';
            const shortEndpoint = endpoint.length > 30 ? endpoint.substring(0, 30) + '...' : endpoint;

            // Format headers for display
            const headers = testCase.header || {};
            const headersText = Object.keys(headers).length > 0
                ? Object.entries(headers).map(([key, value]) => `${key}: ${value}`).join('; ')
                : 'N/A';
            const shortHeaders = headersText.length > 40 ? headersText.substring(0, 40) + '...' : headersText;

            // Get test case ID using helper function for consistency
            const testCaseApiId = getTestCaseId(testCase) || `test-case-${globalIndex}`;
            const checkboxId = `testCaseCheckbox_${globalIndex}`;

            // Check if test case is selected (from database or user selection)
            const isSelected = testCase.is_selected === true || selectedTestCasesSet.has(testCaseApiId);

            // If selected from database, add to Set
            if (testCase.is_selected === true && testCaseApiId) {
                selectedTestCasesSet.add(testCaseApiId);
            }

            row.innerHTML = `
            <td class="text-center">
                <input type="checkbox" 
                       class="form-check-input test-case-checkbox" 
                       id="${checkboxId}"
                       data-test-case-id="${testCaseApiId}"
                       data-index="${globalIndex}"
                       ${isSelected ? 'checked' : ''}
                       onchange="handleTestCaseCheckboxChange(this)">
            </td>
            <td><code class="text-primary">${testCase.test_case_id || `TC-${String(globalIndex + 1).padStart(3, '0')}`}</code></td>
            <td title="${testCaseName}"><strong>${shortName}</strong></td>
            <td><span class="badge ${categoryClass}">${category}</span></td>
            <td class="text-center">
                <span class="badge ${statusClass}">${statusCode}</span>
            </td>
            <td class="text-center">
                <button class="btn btn-sm btn-outline-primary" onclick="viewTestCaseDetails(${globalIndex}, '${testCaseApiId}')" title="Xem chi tiết" data-test-case-id="${testCaseApiId}">
                    <i class="bi bi-eye"></i> Details
                </button>
            </td>
        `;
            tbody.appendChild(row);
        });

        // Update count text
        const totalCount = testCasesToRender.length;
        const allCount = allTestCases.length;
        let countText = '';
        if (currentEndpointFilter && currentEndpointFilter !== '') {
            countText = `<i class="bi bi-info-circle"></i> Hiển thị <strong>${startIndex + 1}-${endIndex}</strong> / <strong>${totalCount}</strong> test cases (tổng: ${allCount})`;
        } else {
            countText = `<i class="bi bi-info-circle"></i> Hiển thị <strong>${startIndex + 1}-${endIndex}</strong> / <strong>${totalCount}</strong> test cases`;
        }
        document.getElementById('testCasesCount').innerHTML = countText;

        // Render pagination
        renderTestCasesPagination(totalPages);

        // Update selected count
        updateSelectedTestCasesCount();
    }

    function renderTestCasesPagination(totalPages) {
        const paginationList = document.getElementById('testCasesPaginationList');
        paginationList.innerHTML = '';

        if (totalPages <= 1) {
            return; // Don't show pagination if only one page or less
        }

        // Previous button
        const prevLi = document.createElement('li');
        prevLi.className = `page-item ${currentTestCasesPage === 1 ? 'disabled' : ''}`;
        prevLi.innerHTML = `
        <a class="page-link" href="#" onclick="goToTestCasesPage(${currentTestCasesPage - 1}); return false;" aria-label="Previous">
            <span aria-hidden="true">&laquo;</span>
        </a>
    `;
        paginationList.appendChild(prevLi);

        // Page numbers
        const maxVisiblePages = 5;
        let startPage = Math.max(1, currentTestCasesPage - Math.floor(maxVisiblePages / 2));
        let endPage = Math.min(totalPages, startPage + maxVisiblePages - 1);

        if (endPage - startPage < maxVisiblePages - 1) {
            startPage = Math.max(1, endPage - maxVisiblePages + 1);
        }

        // First page
        if (startPage > 1) {
            const firstLi = document.createElement('li');
            firstLi.className = 'page-item';
            firstLi.innerHTML = `<a class="page-link" href="#" onclick="goToTestCasesPage(1); return false;">1</a>`;
            paginationList.appendChild(firstLi);

            if (startPage > 2) {
                const ellipsisLi = document.createElement('li');
                ellipsisLi.className = 'page-item disabled';
                ellipsisLi.innerHTML = `<span class="page-link">...</span>`;
                paginationList.appendChild(ellipsisLi);
            }
        }

        // Page range
        for (let i = startPage; i <= endPage; i++) {
            const pageLi = document.createElement('li');
            pageLi.className = `page-item ${i === currentTestCasesPage ? 'active' : ''}`;
            pageLi.innerHTML = `<a class="page-link" href="#" onclick="goToTestCasesPage(${i}); return false;">${i}</a>`;
            paginationList.appendChild(pageLi);
        }

        // Last page
        if (endPage < totalPages) {
            if (endPage < totalPages - 1) {
                const ellipsisLi = document.createElement('li');
                ellipsisLi.className = 'page-item disabled';
                ellipsisLi.innerHTML = `<span class="page-link">...</span>`;
                paginationList.appendChild(ellipsisLi);
            }

            const lastLi = document.createElement('li');
            lastLi.className = 'page-item';
            lastLi.innerHTML = `<a class="page-link" href="#" onclick="goToTestCasesPage(${totalPages}); return false;">${totalPages}</a>`;
            paginationList.appendChild(lastLi);
        }

        // Next button
        const nextLi = document.createElement('li');
        nextLi.className = `page-item ${currentTestCasesPage === totalPages ? 'disabled' : ''}`;
        nextLi.innerHTML = `
        <a class="page-link" href="#" onclick="goToTestCasesPage(${currentTestCasesPage + 1}); return false;" aria-label="Next">
            <span aria-hidden="true">&raquo;</span>
        </a>
    `;
        paginationList.appendChild(nextLi);
    }

    function goToTestCasesPage(page) {
        const totalPages = Math.ceil(allTestCases.length / TEST_CASES_PER_PAGE);
        if (page < 1 || page > totalPages) {
            return;
        }
        currentTestCasesPage = page;
        renderTestCasesPage();

        // Scroll to top of table
        document.getElementById('testCasesTable').scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }

    function refreshTestCases() {
        const projectUuid = '{{ project.uuid }}';
        const btn = document.getElementById('refreshTestCasesBtn');
        const originalHtml = btn.innerHTML;
        btn.innerHTML = '<i class="bi bi-arrow-clockwise"></i> Đang tải...';
        btn.disabled = true;

        fetchTestCases(projectUuid);

        setTimeout(() => {
            btn.innerHTML = originalHtml;
            btn.disabled = false;
            showNotification('success', 'Thành công!', 'Đã làm mới danh sách test cases.');
        }, 1000);
    }

    function quickSelectTestCases() {
        // Scroll to test cases section and select all
        const testCasesContainer = document.getElementById('testCaseResultsContainer');

        if (!testCasesContainer || testCasesContainer.style.display === 'none') {
            // If results container is not visible, fetch test cases first
            const projectUuid = '{{ project.uuid }}';
            fetchTestCases(projectUuid);
            setTimeout(() => {
                const container = document.getElementById('testCaseResultsContainer');
                if (container) {
                    container.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    // Select all after loading
                    setTimeout(() => {
                        // Select all test cases in filtered scope (or all if no filter)
                        const testCasesToSelect = filteredTestCases.length > 0 ? filteredTestCases : allTestCases;
                        testCasesToSelect.forEach(tc => {
                            const testCaseId = getTestCaseId(tc);
                            if (testCaseId) {
                                selectedTestCasesSet.add(testCaseId);
                            }
                        });

                        // Update UI
                        const selectAllCheckbox = document.getElementById('selectAllTestCases');
                        if (selectAllCheckbox) {
                            selectAllCheckbox.checked = true;
                            selectAllCheckbox.indeterminate = false;
                        }

                        // Update visible checkboxes
                        const checkboxes = document.querySelectorAll('.test-case-checkbox');
                        checkboxes.forEach(cb => {
                            const testCaseId = cb.getAttribute('data-test-case-id');
                            cb.checked = testCaseId && selectedTestCasesSet.has(testCaseId);
                        });

                        updateSelectedTestCasesCount();

                        // Save all selections immediately
                        const allTestCaseIds = Array.from(selectedTestCasesSet);
                        if (allTestCaseIds.length > 0) {
                            saveMultipleTestCaseSelections(allTestCaseIds, true);
                        }
                    }, 500);
                    showNotification('info', 'Đã tải!', 'Đã tải và chọn tất cả test cases.');
                }
            }, 1000);
        } else {
            testCasesContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });

            // Highlight the container briefly
            testCasesContainer.style.transition = 'box-shadow 0.3s ease';
            testCasesContainer.style.boxShadow = '0 0 20px rgba(13, 202, 240, 0.5)';
            setTimeout(() => {
                testCasesContainer.style.boxShadow = '';
            }, 2000);

            // Select all test cases in filtered scope (or all if no filter)
            const testCasesToSelect = filteredTestCases.length > 0 ? filteredTestCases : allTestCases;
            testCasesToSelect.forEach(tc => {
                const testCaseId = getTestCaseId(tc);
                if (testCaseId) {
                    selectedTestCasesSet.add(testCaseId);
                }
            });

            // Update UI
            const selectAllCheckbox = document.getElementById('selectAllTestCases');
            if (selectAllCheckbox) {
                selectAllCheckbox.checked = true;
                selectAllCheckbox.indeterminate = false;
            }

            // Update visible checkboxes on current page
            const checkboxes = document.querySelectorAll('.test-case-checkbox');
            checkboxes.forEach(cb => {
                const testCaseId = cb.getAttribute('data-test-case-id');
                cb.checked = testCaseId && selectedTestCasesSet.has(testCaseId);
            });

            updateSelectedTestCasesCount();

            // Save all selections immediately
            const allTestCaseIds = Array.from(selectedTestCasesSet);
            if (allTestCaseIds.length > 0) {
                saveMultipleTestCaseSelections(allTestCaseIds, true);
            }

            const selectedCount = testCasesToSelect.length;
            const filterInfo = (currentTestSuiteFilter || currentEndpointFilter) 
                ? ` (trong phạm vi đã lọc)` 
                : '';
            showNotification('success', 'Đã chọn tất cả!', `Đã chọn tất cả ${selectedCount} test cases${filterInfo}.`);
        }
    }

    // Test Case Selection Functions
    function updateSelectedTestCasesCount() {
        // Count from global Set, not just visible checkboxes
        const count = selectedTestCasesSet.size;
        const countElement = document.getElementById('selectedTestCasesCount');
        if (countElement) {
            countElement.textContent = count;
        }

        // Update testCasesSelected flag and show Next button if any test case is selected
        const hasSelected = count > 0;
        window.testCasesSelected = hasSelected;
        if (currentStep === 4) {
            updateNavigationButtons(4);
        }

        // Update select all checkbox state based on filtered test cases (or all if no filter)
        const selectAllCheckbox = document.getElementById('selectAllTestCases');
        const testCasesToCheck = filteredTestCases.length > 0 ? filteredTestCases : allTestCases;
        
        if (selectAllCheckbox && testCasesToCheck.length > 0) {
            const testCasesIds = testCasesToCheck.map(tc => {
                return (tc.full_test_case_data && tc.full_test_case_data.id)
                    ? tc.full_test_case_data.id
                    : (tc.uuid || '');
            }).filter(id => id); // Filter out empty IDs

            const allSelected = testCasesIds.length > 0 &&
                testCasesIds.every(id => selectedTestCasesSet.has(id));
            const someSelected = testCasesIds.some(id => selectedTestCasesSet.has(id));

            selectAllCheckbox.checked = allSelected;
            selectAllCheckbox.indeterminate = someSelected && !allSelected;
        }
    }

    // Update selection state when checkbox is clicked
    function handleTestCaseCheckboxChange(checkbox) {
        const testCaseId = checkbox.getAttribute('data-test-case-id');
        if (testCaseId) {
            const isSelected = checkbox.checked;

            if (isSelected) {
                selectedTestCasesSet.add(testCaseId);
            } else {
                selectedTestCasesSet.delete(testCaseId);
            }
            updateSelectedTestCasesCount();

            // Save selection immediately
            saveSingleTestCaseSelection(testCaseId, isSelected);
        }
    }

    // Function to save a single test case selection immediately
    function saveSingleTestCaseSelection(testCaseId, isSelected) {
        console.log(`Saving test case selection: ${testCaseId}, isSelected: ${isSelected}`);

        const projectUuid = '{{ project.uuid }}';
        const payload = {
            test_case_ids: [testCaseId],
            execute: isSelected  // true to select, false to deselect
        };

        fetch(`/project/${projectUuid}/test-cases/select/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
            },
            body: JSON.stringify(payload),
            _noLoading: true,  // Bỏ qua loading overlay để không gây khó chịu
            _timeoutMs: 30000,
            _retries: 1
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Selection saved successfully
                    console.log(`Test case ${testCaseId} ${isSelected ? 'selected' : 'deselected'} successfully`);

                    // Update testCasesSelected flag and show Next button if any test case is selected
                    const hasSelected = selectedTestCasesSet.size > 0;
                    window.testCasesSelected = hasSelected;
                    updateNavigationButtons(4);
                } else {
                    // Revert checkbox state on error
                    const checkbox = document.querySelector(`[data-test-case-id="${testCaseId}"]`);
                    if (checkbox) {
                        checkbox.checked = !isSelected;
                        if (isSelected) {
                            selectedTestCasesSet.delete(testCaseId);
                        } else {
                            selectedTestCasesSet.add(testCaseId);
                        }
                        updateSelectedTestCasesCount();
                    }
                    showNotification('error', 'Lỗi!', data.message || 'Không thể lưu lựa chọn test case.');
                }
            })
            .catch(error => {
                console.error('Error saving test case selection:', error);
                // Revert checkbox state on error
                const checkbox = document.querySelector(`[data-test-case-id="${testCaseId}"]`);
                if (checkbox) {
                    checkbox.checked = !isSelected;
                    if (isSelected) {
                        selectedTestCasesSet.delete(testCaseId);
                    } else {
                        selectedTestCasesSet.add(testCaseId);
                    }
                    updateSelectedTestCasesCount();
                }
                showNotification('error', 'Lỗi!', 'Đã xảy ra lỗi khi lưu lựa chọn test case.');
            });
    }

    function toggleAllTestCases(checkbox) {
        const isSelected = checkbox.checked;

        // Select/deselect test cases in filtered scope (or all if no filter)
        if (isSelected) {
            // Add all test case IDs from filtered scope to the Set
            const testCasesToSelect = filteredTestCases.length > 0 ? filteredTestCases : allTestCases;
            testCasesToSelect.forEach(tc => {
                const testCaseId = getTestCaseId(tc);
                if (testCaseId) {
                    selectedTestCasesSet.add(testCaseId);
                }
            });
        } else {
            // Remove test case IDs from filtered scope (or all if no filter)
            const testCasesToDeselect = filteredTestCases.length > 0 ? filteredTestCases : allTestCases;
            testCasesToDeselect.forEach(tc => {
                const testCaseId = getTestCaseId(tc);
                if (testCaseId) {
                    selectedTestCasesSet.delete(testCaseId);
                }
            });
        }

        // Update visible checkboxes on current page
        const checkboxes = document.querySelectorAll('.test-case-checkbox');
        checkboxes.forEach(cb => {
            const testCaseId = cb.getAttribute('data-test-case-id');
            cb.checked = testCaseId && selectedTestCasesSet.has(testCaseId);
        });

        updateSelectedTestCasesCount();

        // Save all selections immediately
        const allTestCaseIds = Array.from(selectedTestCasesSet);
        if (allTestCaseIds.length > 0) {
            saveMultipleTestCaseSelections(allTestCaseIds, isSelected);
        }
    }

    // Function to save multiple test case selections (for select all/deselect all)
    function saveMultipleTestCaseSelections(testCaseIds, isSelected) {
        console.log(`Saving ${testCaseIds.length} test case selections: isSelected=${isSelected}`);

        const projectUuid = '{{ project.uuid }}';
        const payload = {
            test_case_ids: testCaseIds,
            execute: isSelected
        };

        fetch(`/project/${projectUuid}/test-cases/select/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
            },
            body: JSON.stringify(payload),
            _noLoading: true,  // Bỏ qua loading overlay để không gây khó chịu
            _timeoutMs: 30000,
            _retries: 1
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    console.log(`Successfully ${isSelected ? 'selected' : 'deselected'} ${testCaseIds.length} test cases`);

                    // Update testCasesSelected flag and show Next button if any test case is selected
                    const hasSelected = selectedTestCasesSet.size > 0;
                    window.testCasesSelected = hasSelected;
                    updateNavigationButtons(4);
                } else {
                    showNotification('error', 'Lỗi!', data.message || 'Không thể lưu lựa chọn test cases.');
                }
            })
            .catch(error => {
                console.error('Error saving test case selections:', error);
                showNotification('error', 'Lỗi!', 'Đã xảy ra lỗi khi lưu lựa chọn test cases.');
            });
    }

    function clearSelectedTestCases() {
        // Get all test case IDs before clearing
        const allTestCaseIds = Array.from(selectedTestCasesSet);

        // Clear all selections from the Set
        selectedTestCasesSet.clear();

        // Update visible checkboxes on current page
        const checkboxes = document.querySelectorAll('.test-case-checkbox');
        checkboxes.forEach(cb => {
            cb.checked = false;
        });

        const selectAllCheckbox = document.getElementById('selectAllTestCases');
        if (selectAllCheckbox) {
            selectAllCheckbox.checked = false;
            selectAllCheckbox.indeterminate = false;
        }

        updateSelectedTestCasesCount();

        // Save deselection immediately if there were any selected
        if (allTestCaseIds.length > 0) {
            saveMultipleTestCaseSelections(allTestCaseIds, false);
        }

        showNotification('info', 'Đã bỏ chọn', 'Đã bỏ chọn tất cả test cases.');
    }

    function submitSelectedTestCases() {
        // Get all selected test case IDs from the Set (across all pages)
        const testCaseIds = Array.from(selectedTestCasesSet);

        if (testCaseIds.length === 0) {
            showNotification('warning', 'Chưa chọn test case', 'Vui lòng chọn ít nhất một test case trước khi xác nhận.');
            return;
        }

        const projectUuid = '{{ project.uuid }}';
        const submitBtn = document.getElementById('submitSelectedTestCasesBtn');
        const originalHtml = submitBtn.innerHTML;

        // Show loading state
        submitBtn.disabled = true;
        submitBtn.innerHTML = '<i class="bi bi-hourglass-split"></i> Đang xử lý...';

        // Prepare payload - set execute: true to mark test cases for execution
        const payload = {
            test_case_ids: testCaseIds,
            execute: true  // Set to true to mark test cases as selected for execution
        };

        // Send request
        fetch(`/project/${projectUuid}/test-cases/select/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
            },
            body: JSON.stringify(payload),
            _timeoutMs: 30000,
            _retries: 1
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showNotification('success', 'Thành công!', data.message || `Đã chọn ${testCaseIds.length} test case(s) thành công.`);

                    // Extract test_suite_id from response and save it for later execution
                    let testSuiteId = null;

                    // Try multiple possible locations for test_suite_id
                    if (data.test_suite_id) {
                        testSuiteId = data.test_suite_id;
                    } else if (data.response) {
                        if (data.response.data) {
                            if (data.response.data.test_suite_id) {
                                testSuiteId = data.response.data.test_suite_id;
                            } else if (typeof data.response.data === 'string') {
                                // Sometimes data might be a string ID
                                testSuiteId = data.response.data;
                            } else if (data.response.data.id) {
                                testSuiteId = data.response.data.id;
                            }
                        }
                        if (!testSuiteId && data.response.test_suite_id) {
                            testSuiteId = data.response.test_suite_id;
                        }
                        if (!testSuiteId && data.response.id) {
                            testSuiteId = data.response.id;
                        }
                    }

                    // Log for debugging
                    console.log('Extracted test_suite_id:', testSuiteId);
                    console.log('Full response data:', data);

                    if (testSuiteId) {
                        // Lưu test_suite_id để dùng khi bấm Next sang step 5
                        window.selectedTestSuiteId = testSuiteId;
                        window.testCasesSelected = true;
                        updateStepLocks();
                        showNotification('success', 'Thành công!', `Đã chọn ${testCaseIds.length} test case(s) thành công. Bấm "Next" để thực thi test suite.`);
                    } else {
                        // Nếu không có test_suite_id, vẫn cho phép chọn (test_suite_id sẽ được lấy từ DB khi execute)
                        window.testCasesSelected = true;
                        updateStepLocks();
                        showNotification('success', 'Thành công!', `Đã chọn ${testCaseIds.length} test case(s) thành công. Bấm "Next" để thực thi test suite.`);
                        console.warn('No test_suite_id in response, will try to get from database when executing');
                    }

                    // Hiển thị lại nút Next và Back sau khi chọn test cases
                    updateNavigationButtons(4);

                    submitBtn.disabled = false;
                    submitBtn.innerHTML = originalHtml;
                } else {
                    showNotification('error', 'Lỗi!', data.message || 'Không thể chọn test cases.');
                    submitBtn.disabled = false;
                    submitBtn.innerHTML = originalHtml;
                }
            })
            .catch(error => {
                console.error('Error selecting test cases:', error);
                showNotification('error', 'Lỗi!', 'Đã xảy ra lỗi khi chọn test cases. Vui lòng thử lại.');
                submitBtn.disabled = false;
                submitBtn.innerHTML = originalHtml;
            });
    }

    function getTestSuiteIdFromDatabase(projectUuid) {
        // Show execution status with progress bar instead of loading page
        showTestExecutionStatus('Đang lấy test suite ID từ database...');

        // Call backend to get test suite ID from database
        fetch(`/project/${projectUuid}/test-suite/get-id/`, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
            },
            _timeoutMs: 10000,
            _retries: 1
        })
            .then(response => response.json())
            .then(data => {
                if (data.success && data.test_suite_id) {
                    // Execute với single test suite ID (fallback case)
                    executeTestSuite(projectUuid, [data.test_suite_id]);
                } else {
                    showNotification('error', 'Lỗi!', data.message || 'Không tìm thấy test_suite_id trong database. Vui lòng đảm bảo test cases đã được generate.');
                    hideReportLoading();
                    console.error('No test_suite_id found in database:', data);
                }
            })
            .catch(error => {
                console.error('Error getting test_suite_id from database:', error);
                showNotification('error', 'Lỗi!', 'Đã xảy ra lỗi khi lấy test_suite_id từ database.');
                hideReportLoading();
            });
    }

    // Helper function to get unique test suite IDs from selected test cases
    function getUniqueTestSuiteIdsFromSelected() {
        const selectedIds = Array.from(selectedTestCasesSet);
        const suiteIdSet = new Set();
        
        allTestCases.forEach(tc => {
            const testCaseId = getTestCaseId(tc);
            if (selectedIds.includes(testCaseId) && tc.test_suite_id) {
                suiteIdSet.add(tc.test_suite_id);
            }
        });
        
        return Array.from(suiteIdSet);
    }

    function executeTestSuite(projectUuid, testSuiteIdOrArray) {
        const submitBtn = document.getElementById('submitSelectedTestCasesBtn');
        if (submitBtn) {
            submitBtn.innerHTML = '<i class="bi bi-play-circle"></i> Đang chạy test suite...';
            submitBtn.disabled = true;
        }

        // Show execution status with progress bar
        showTestExecutionStatus('Đang khởi động chạy test suite...');

        // Move to step 5 (don't show loading page, use progress bar instead)
        setStep(5);
        // showReportLoading is removed - we use testExecutionStatusContainer with progress bar instead

        // Determine test suite IDs to execute
        let testSuiteIds = [];
        if (Array.isArray(testSuiteIdOrArray)) {
            testSuiteIds = testSuiteIdOrArray;
        } else if (testSuiteIdOrArray) {
            testSuiteIds = [testSuiteIdOrArray];
        } else {
            // If no test suite ID provided, get from selected test cases
            testSuiteIds = getUniqueTestSuiteIdsFromSelected();
        }

        if (testSuiteIds.length === 0) {
            showNotification('error', 'Lỗi!', 'Không tìm thấy test suite để thực thi.');
            hideReportLoading();
            hideTestExecutionStatus();
            if (submitBtn) {
                submitBtn.disabled = false;
                submitBtn.innerHTML = '<i class="bi bi-check-circle"></i> Xác Nhận Chọn Test Cases (<span id="selectedTestCasesCount">0</span>)';
            }
            return;
        }

        console.log(`Executing ${testSuiteIds.length} test suite(s):`, testSuiteIds);
        updateTestExecutionStatus(`Đang khởi động chạy ${testSuiteIds.length} test suite(s)...`);

        // Execute test suites sequentially and collect report IDs
        const reportIds = [];
        let currentIndex = 0;

        const executeNext = () => {
            if (currentIndex >= testSuiteIds.length) {
                // All suites executed, start polling all reports
                if (reportIds.length > 0) {
                    console.log(`All ${testSuiteIds.length} test suite(s) executed. Report IDs:`, reportIds);
                    updateTestExecutionStatus(`Đã khởi động ${testSuiteIds.length} test suite(s). Đang chờ reports...`);
                    pollTestReport(projectUuid, reportIds);
                } else {
                    showNotification('error', 'Lỗi!', 'Không nhận được report ID từ bất kỳ test suite nào.');
                    hideReportLoading();
                    hideTestExecutionStatus();
                    if (submitBtn) {
                        submitBtn.disabled = false;
                        submitBtn.innerHTML = '<i class="bi bi-check-circle"></i> Xác Nhận Chọn Test Cases (<span id="selectedTestCasesCount">0</span>)';
                    }
                }
                return;
            }

            const testSuiteId = testSuiteIds[currentIndex];
            updateTestExecutionStatus(`Đang khởi động test suite ${currentIndex + 1}/${testSuiteIds.length}...`);

            // Call execute API for this test suite
            fetch(`/project/${projectUuid}/test-suite/execute/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
                },
                body: JSON.stringify({
                    test_suite_id: testSuiteId
                }),
                _timeoutMs: 30000,
                _retries: 1
            })
                .then(response => response.json())
                .then(data => {
                    if (data.success && data.test_suite_report_id) {
                        reportIds.push(data.test_suite_report_id);
                        console.log(`Test suite ${currentIndex + 1}/${testSuiteIds.length} executed. Report ID:`, data.test_suite_report_id);
                        currentIndex++;
                        executeNext(); // Execute next suite
                    } else {
                        console.error(`Failed to execute test suite ${currentIndex + 1}:`, data.message || 'No report ID');
                        // Continue with next suite even if this one failed
                        currentIndex++;
                        executeNext();
                    }
                })
                .catch(error => {
                    console.error(`Error executing test suite ${currentIndex + 1}:`, error);
                    // Continue with next suite even if this one failed
                    currentIndex++;
                    executeNext();
                });
        };

        // Start executing first suite
        executeNext();
    }


    // Helper function to check if report has actual data
    function hasReportData(reportData) {
        if (!reportData || !reportData.success) return false;
        
        // Check test_results in various possible locations
        const responseData = reportData.response || {};
        const dataObj = reportData.data || {};
        
        // Check test_results array - can be at top level of response or nested
        let testResults = [];
        if (responseData.test_results && Array.isArray(responseData.test_results)) {
            testResults = responseData.test_results;
        } else if (responseData.data && responseData.data.test_results && Array.isArray(responseData.data.test_results)) {
            testResults = responseData.data.test_results;
        } else if (dataObj.test_results && Array.isArray(dataObj.test_results)) {
            testResults = dataObj.test_results;
        } else if (Array.isArray(responseData.data)) {
            testResults = responseData.data;
        } else if (Array.isArray(dataObj.data)) {
            testResults = dataObj.data;
        }
        
        // Check if test_results has items
        if (testResults.length > 0) {
            return true;
        }
        
        // Check if data is an array with items
        const dataArray = Array.isArray(reportData.data) ? reportData.data : 
                        Array.isArray(responseData.data) ? responseData.data : [];
        if (dataArray.length > 0) {
            return true;
        }
        
        return false;
    }

    function pollTestReport(projectUuid, testSuiteReportIdOrList) {
        // Support single ID or array of IDs (poll all in parallel, but only display when all have data)
        const reportIds = Array.isArray(testSuiteReportIdOrList)
            ? [...testSuiteReportIdOrList]
            : [testSuiteReportIdOrList];

        // Reset aggregated report storage for this polling session
        window.allTestResults = [];
        window.allReportsMeta = [];
        window.currentReportIds = reportIds.slice();
        window.reportDataMap = {}; // Store data for each report ID: {reportId: reportData}

        const maxAttempts = 60; // Poll for up to 5 minutes (60 * 5 seconds)
        const pollInterval = 5000; // Poll every 5 seconds
        const initialDelay = 30000; // Wait 30 seconds before first request

        // Ensure we're on step 5
        setStep(5);
        console.log(`Starting to poll ${reportIds.length} report(s):`, reportIds);
        console.log(`Will wait ${initialDelay / 1000} seconds before first request...`);

        let attempts = 0;
        const reportStatusMap = {}; // Track status for each report: {reportId: {hasData: bool, attempts: number}}

        // Initialize status map
        reportIds.forEach(id => {
            reportStatusMap[id] = { hasData: false, attempts: 0 };
        });

        const poll = () => {
            attempts++;

            if (attempts > maxAttempts) {
                showNotification('error', 'Timeout', 'Đã hết thời gian chờ report. Vui lòng thử lại.');
                hideReportLoading();
                hideTestExecutionStatus();
                const submitBtn = document.getElementById('submitSelectedTestCasesBtn');
                if (submitBtn) {
                    submitBtn.disabled = false;
                    submitBtn.innerHTML = '<i class="bi bi-check-circle"></i> Xác Nhận Chọn Test Cases (<span id="selectedTestCasesCount">0</span>)';
                }
                return;
            }

            // Count how many reports have data
            const reportsWithData = Object.values(reportStatusMap).filter(status => status.hasData).length;
            updateTestExecutionStatus(`Đang lấy reports... (${reportsWithData}/${reportIds.length} có data, Lần thử: ${attempts}/${maxAttempts})`);

            // Poll all reports in parallel
            const pollPromises = reportIds.map(reportId => {
                // Skip if this report already has data
                if (reportStatusMap[reportId].hasData) {
                    return Promise.resolve({ reportId, skip: true });
                }

                reportStatusMap[reportId].attempts++;

                return fetch(`/project/${projectUuid}/test-report/${reportId}/`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
                    },
                    _timeoutMs: 10000,
                    _retries: 1
                })
                    .then(response => response.json())
                    .then(data => {
                        return { reportId, data };
                    })
                    .catch(error => {
                        console.error(`❌ Error polling report ${reportId} (attempt ${attempts}):`, error);
                        return { reportId, error };
                    });
            });

            Promise.all(pollPromises).then(results => {
                let allHaveData = true;
                let hasNewData = false;

                results.forEach(({ reportId, data, error, skip }) => {
                    if (skip) {
                        return; // Already has data, skip
                    }

                    if (error) {
                        // Network error, continue polling
                        return;
                    }

                    if (data.success && hasReportData(data)) {
                        // This report has data now
                        if (!reportStatusMap[reportId].hasData) {
                            reportStatusMap[reportId].hasData = true;
                            window.reportDataMap[reportId] = data;
                            hasNewData = true;
                            console.log(`✅ Report ${reportId} is ready with data!`);
                        }
                    } else if (data.success && !hasReportData(data)) {
                        // Report API returned success but no data yet
                        console.log(`⏳ Report ${reportId} API returned success but no data yet (attempt ${attempts})`);
                    } else if (data.message && (
                        data.message.includes('not found') ||
                        data.message.includes('chưa sẵn sàng') ||
                        data.message.includes('chưa hoàn thành') ||
                        data.message.includes('chưa có') ||
                        data.message.includes('not ready') ||
                        data.message.includes('chưa có dữ liệu')
                    )) {
                        // Report not ready yet, continue polling
                        console.log(`⏳ Report ${reportId} not ready yet (attempt ${attempts})`);
                    } else {
                        // Error getting report
                        console.error(`❌ Error getting report ${reportId}:`, data.message);
                    }

                    // Check if this report still doesn't have data
                    if (!reportStatusMap[reportId].hasData) {
                        allHaveData = false;
                    }
                });

                // If all reports have data, display them
                if (allHaveData && reportIds.length > 0) {
                    console.log('✅ All reports have data! Displaying...');
                    window.testReportReady = true;
                    
                    // Save report IDs to URL for reload persistence
                    const url = new URL(window.location.href);
                    if (reportIds.length === 1) {
                        url.searchParams.set('report_id', reportIds[0]);
                    } else {
                        // For multiple reports, save as comma-separated list
                        url.searchParams.set('report_ids', reportIds.join(','));
                        url.searchParams.delete('report_id'); // Remove single report_id if exists
                    }
                    url.searchParams.set('step', '5');
                    window.history.replaceState({}, '', url.toString());
                    
                    // Also save to localStorage as backup
                    localStorage.setItem(`project_reports_${projectUuid}`, JSON.stringify(reportIds));
                    
                    // Display all reports (append mode)
                    reportIds.forEach(reportId => {
                        if (window.reportDataMap[reportId]) {
                            displayTestReport(window.reportDataMap[reportId], reportId, true);
                        }
                    });
                    
                    hideReportLoading();
                    hideTestExecutionStatus();
                    const submitBtn = document.getElementById('submitSelectedTestCasesBtn');
                    if (submitBtn) {
                        submitBtn.disabled = false;
                        submitBtn.innerHTML = '<i class="bi bi-check-circle"></i> Xác Nhận Chọn Test Cases (<span id="selectedTestCasesCount">0</span>)';
                    }
                    showNotification('success', 'Hoàn thành!', `Đã lấy ${reportIds.length} report(s) thành công.`);
                } else {
                    // Continue polling
                    setTimeout(poll, pollInterval);
                }
            });
        };

        updateTestExecutionStatus(`Đang chờ ${initialDelay / 1000} giây trước khi bắt đầu lấy ${reportIds.length} report(s)...`);
        setTimeout(() => {
            console.log('Initial delay completed, starting first poll request...');
            poll();
        }, initialDelay);
    }

    function showTestExecutionStatus(message) {
        let statusContainer = document.getElementById('testExecutionStatusContainer');
        if (!statusContainer) {
            // Create status container
            statusContainer = document.createElement('div');
            statusContainer.id = 'testExecutionStatusContainer';
            statusContainer.className = 'card mt-3 shadow-sm';
            statusContainer.innerHTML = `
                <div class="card-header bg-primary text-white">
                    <h6 class="mb-0"><i class="bi bi-play-circle"></i> Đang chạy Test Suite</h6>
                </div>
                <div class="card-body">
                    <div class="d-flex align-items-center">
                        <div class="spinner-border spinner-border-sm text-primary me-3" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                        <div>
                            <p class="mb-0" id="testExecutionStatusMessage">${message}</p>
                            <div class="progress mt-2" style="height: 6px;">
                                <div class="progress-bar progress-bar-striped progress-bar-animated" 
                                     id="testExecutionProgressBar" 
                                     role="progressbar" 
                                     style="width: 0%"></div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            // Insert after test case results container
            const resultsContainer = document.getElementById('testCaseResultsContainer');
            if (resultsContainer && resultsContainer.parentNode) {
                resultsContainer.parentNode.insertBefore(statusContainer, resultsContainer.nextSibling);
            } else {
                // Fallback: insert in phase4 card body
                const phase4 = document.getElementById('phase4');
                if (phase4) {
                    phase4.querySelector('.card-body').appendChild(statusContainer);
                }
            }
        } else {
            document.getElementById('testExecutionStatusMessage').textContent = message;
            statusContainer.style.display = 'block';
        }
    }

    function updateTestExecutionStatus(message) {
        const messageEl = document.getElementById('testExecutionStatusMessage');
        if (messageEl) {
            messageEl.textContent = message;
        }
    }

    function hideTestExecutionStatus() {
        const statusContainer = document.getElementById('testExecutionStatusContainer');
        if (statusContainer) {
            statusContainer.style.display = 'none';
        }
    }

    // Report Loading Functions
    function showReportLoading(message) {
        const loadingContainer = document.getElementById('reportLoadingContainer');
        const contentContainer = document.getElementById('reportContentContainer');
        if (loadingContainer) {
            loadingContainer.style.display = 'block';
            document.getElementById('reportLoadingText').textContent = message || 'Đang chờ test suite thực thi...';
            document.getElementById('reportLoadingMessage').textContent = 'Vui lòng chờ trong giây lát...';
        }
        if (contentContainer) {
            contentContainer.style.display = 'none';
        }
    }

    function updateReportLoading(message, progress) {
        const loadingText = document.getElementById('reportLoadingText');
        const loadingMessage = document.getElementById('reportLoadingMessage');
        const progressBar = document.getElementById('reportLoadingProgressBar');
        if (loadingText) loadingText.textContent = message || 'Đang chờ test suite thực thi...';
        if (loadingMessage) loadingMessage.textContent = 'Vui lòng chờ trong giây lát...';
        if (progressBar && progress !== undefined) {
            progressBar.style.width = progress + '%';
        }
    }

    function hideReportLoading() {
        const loadingContainer = document.getElementById('reportLoadingContainer');
        if (loadingContainer) {
            loadingContainer.style.display = 'none';
        }
    }

    function displayTestReport(reportData, testSuiteReportId, append = false) {
        // Maintain aggregated test results across multiple reports
        if (!window.allTestResults) window.allTestResults = [];
        if (!window.allReportsMeta) window.allReportsMeta = [];
        if (!append) {
            window.allTestResults = [];
            window.allReportsMeta = [];
        }

        // Hide loading, show content
        hideReportLoading();
        const contentContainer = document.getElementById('reportContentContainer');
        if (contentContainer) {
            contentContainer.style.display = 'block';
        }

        // Extract report data - format: {success: true, message: "...", data: [...]}
        const reportDataArray = reportData.data || reportData.response?.data || [];
        const result = reportData.result || reportData.response?.result || {};
        
        // Get test suite name and ID from response (from Django database)
        const reportTestSuiteName = reportData.test_suite_name || reportData.response?.test_suite_name;
        const reportTestSuiteId = reportData.test_suite_id || reportData.response?.test_suite_id;

        // Store report data globally for refresh/aggregate
        window.currentReportData = reportData;
        window.currentTestSuiteReportId = testSuiteReportId;
        window.allReportsMeta.push({
            report_id: testSuiteReportId,
            result: result,
            raw: reportData,
            test_suite_name: reportTestSuiteName,
            test_suite_id: reportTestSuiteId
        });

        // Parse test results - data is an array directly
        let testResults = [];
        let totalTests = 0;
        let passedTests = 0;
        let failedTests = 0;
        let pendingTests = 0;

        // Check if data is an array
        if (Array.isArray(reportDataArray)) {
            testResults = reportDataArray;
        } else if (reportDataArray && Array.isArray(reportDataArray.data)) {
            testResults = reportDataArray.data;
        } else if (reportDataArray && Array.isArray(reportDataArray.test_results)) {
            testResults = reportDataArray.test_results;
        }

        // Extract test_suite_report_id from first test result if available
        if (testResults.length > 0 && testResults[0].test_suite_report_id && !testSuiteReportId) {
            window.currentTestSuiteReportId = testResults[0].test_suite_report_id;
        }

        // Aggregate
        window.allTestResults = window.allTestResults.concat(testResults);
        const aggregatedResults = window.allTestResults;
        console.log('Parsed test results (this report):', testResults.length);
        console.log('Aggregated test results:', aggregatedResults.length);

        // Build test suite name to ID mapping from allTestCases
        const suiteNameToIdMap = {}; // {suite_name: [suite_ids]}
        const suiteIdToNameMap = {}; // {suite_id: suite_name}
        
        // Priority 1: Add test suite names from ALL reports in allReportsMeta (not just current report)
        // This ensures we capture all test suites from multiple reports
        if (window.allReportsMeta && Array.isArray(window.allReportsMeta)) {
            window.allReportsMeta.forEach(meta => {
                if (meta.test_suite_name && meta.test_suite_id) {
                    suiteIdToNameMap[meta.test_suite_id] = meta.test_suite_name;
                    if (!suiteNameToIdMap[meta.test_suite_name]) {
                        suiteNameToIdMap[meta.test_suite_name] = new Set();
                    }
                    suiteNameToIdMap[meta.test_suite_name].add(meta.test_suite_id);
                    console.log(`Added test suite from report meta: ${meta.test_suite_name} (${meta.test_suite_id})`);
                }
            });
        }
        
        // Priority 1.5: Add test suite name from current report response (from Django database)
        // This handles the case where report is just being loaded
        if (reportTestSuiteName && reportTestSuiteId) {
            suiteIdToNameMap[reportTestSuiteId] = reportTestSuiteName;
            if (!suiteNameToIdMap[reportTestSuiteName]) {
                suiteNameToIdMap[reportTestSuiteName] = new Set();
            }
            suiteNameToIdMap[reportTestSuiteName].add(reportTestSuiteId);
            console.log(`Added test suite from current report response: ${reportTestSuiteName} (${reportTestSuiteId})`);
        }
        
        // Priority 2: Add from allTestCases (this should have all test suites in the project)
        if (window.allTestCases && Array.isArray(window.allTestCases)) {
            window.allTestCases.forEach(tc => {
                if (tc.test_suite_id && tc.test_suite_name) {
                    suiteIdToNameMap[tc.test_suite_id] = tc.test_suite_name;
                    if (!suiteNameToIdMap[tc.test_suite_name]) {
                        suiteNameToIdMap[tc.test_suite_name] = new Set();
                    }
                    suiteNameToIdMap[tc.test_suite_name].add(tc.test_suite_id);
                }
            });
            console.log(`Added ${Object.keys(suiteIdToNameMap).length} test suites from allTestCases`);
        }

        // Extract test suite names from test results and build mapping
        aggregatedResults.forEach(test => {
            const testCaseObj = test.test_case || {};
            // Try multiple ways to get suite ID
            let suiteId = testCaseObj.test_suite_id || test.test_suite_id || test.test_suite?.id;
            
            // Try multiple ways to get suite name
            let suiteName = testCaseObj.test_suite_name 
                || test.test_suite_name 
                || test.test_suite?.name 
                || test.test_suite?.test_suite_name;
            
            // Priority 1: If we have suite ID, try to get name from the pre-built map
            // (from report response or allTestCases)
            if (suiteId && !suiteName && suiteIdToNameMap[suiteId]) {
                suiteName = suiteIdToNameMap[suiteId];
            }
            
            // Priority 1.5: If we still don't have suiteName but have reportTestSuiteId matching, use report name
            // ONLY if the suiteId matches or if we have no suiteId at all (fallback)
            // This ensures we don't force all test results to use the same test suite name
            if (!suiteName && reportTestSuiteId && reportTestSuiteName) {
                // Only use report name if suiteId matches OR if we have no suiteId (true fallback)
                if (suiteId === reportTestSuiteId) {
                    suiteName = reportTestSuiteName;
                } else if (!suiteId) {
                    // Only use as fallback if we truly have no suiteId
                    // But first check if we can find suiteId from test result structure
                    suiteName = reportTestSuiteName;
                    suiteId = reportTestSuiteId;
                }
            }
            
            // Priority 2: If we have suite ID but no name, try to get from test_suite object
            if (suiteId && !suiteName && test.test_suite) {
                suiteName = test.test_suite.name || test.test_suite.test_suite_name || test.test_suite.title;
            }
            
            // Priority 3: Try to find test case in window.allTestCases by test_case_id
            if ((!suiteId || !suiteName) && window.allTestCases && Array.isArray(window.allTestCases)) {
                const testCaseId = test.test_case_id || testCaseObj.id || testCaseObj.test_case_id;
                if (testCaseId) {
                    // Try multiple matching strategies
                    const matchingTestCase = window.allTestCases.find(tc => {
                        // Match by UUID (most common)
                        if (tc.uuid === testCaseId) return true;
                        // Match by id
                        if (tc.id === testCaseId) return true;
                        // Match by test_case_id (formatted)
                        if (tc.test_case_id === testCaseId) return true;
                        // Match by full_test_case_data.id
                        if (tc.full_test_case_data && tc.full_test_case_data.id === testCaseId) return true;
                        // Match by removing "TC-" prefix if present
                        const cleanId = testCaseId.replace(/^TC-/, '');
                        if (tc.uuid === cleanId || tc.id === cleanId) return true;
                        return false;
                    });
                    if (matchingTestCase) {
                        if (!suiteId && matchingTestCase.test_suite_id) {
                            suiteId = matchingTestCase.test_suite_id;
                        }
                        if (!suiteName && matchingTestCase.test_suite_name) {
                            suiteName = matchingTestCase.test_suite_name;
                        }
                        // Also check if we now have suiteId and can get name from map
                        if (suiteId && !suiteName && suiteIdToNameMap[suiteId]) {
                            suiteName = suiteIdToNameMap[suiteId];
                        }
                    }
                }
            }
            
            // Priority 4: If we have suiteId but still no name, try one more time from map
            // (in case allTestCases was updated after initial mapping)
            if (suiteId && !suiteName && suiteIdToNameMap[suiteId]) {
                suiteName = suiteIdToNameMap[suiteId];
            }
            
            // Priority 5: If we still don't have a name but have suiteId, 
            // try to find any test case with this suiteId in allTestCases
            if (suiteId && !suiteName && window.allTestCases && Array.isArray(window.allTestCases)) {
                const anyTestCaseWithSuite = window.allTestCases.find(tc => tc.test_suite_id === suiteId);
                if (anyTestCaseWithSuite && anyTestCaseWithSuite.test_suite_name) {
                    suiteName = anyTestCaseWithSuite.test_suite_name;
                }
            }
            
            // Priority 6: If we still don't have suiteName but have reportTestSuiteName,
            // use it as fallback ONLY if we have no suiteId at all
            // This prevents forcing all test results to use the same test suite name
            // when they might belong to different test suites
            if (!suiteName && !suiteId && reportTestSuiteName) {
                // Only use as absolute last resort when we have no suite info at all
                suiteName = reportTestSuiteName;
                if (reportTestSuiteId) {
                    suiteId = reportTestSuiteId;
                }
            }
            
            // Only skip if we absolutely cannot find a name
            // This ensures we only show meaningful names to users
            if (!suiteName) {
                // Skip this entry - we need a real name, not just an ID
                return;
            }
            
            // Add to map if we have a valid suite name
            if (suiteName) {
                if (suiteId) {
                    suiteIdToNameMap[suiteId] = suiteName;
                }
                if (!suiteNameToIdMap[suiteName]) {
                    suiteNameToIdMap[suiteName] = new Set();
                }
                if (suiteId) {
                    suiteNameToIdMap[suiteName].add(suiteId);
                }
            }
        });
        
        // Debug logging
        console.log('=== Test Suite Mapping Debug ===');
        console.log('Suite name to ID map:', suiteNameToIdMap);
        console.log('Suite ID to name map:', suiteIdToNameMap);
        console.log('Number of unique test suites found:', Object.keys(suiteNameToIdMap).length);
        console.log('Test suites found:', Object.keys(suiteNameToIdMap));
        console.log('Total aggregated test results:', aggregatedResults.length);
        if (Object.keys(suiteNameToIdMap).length === 0 && aggregatedResults.length > 0) {
            console.warn('No test suite names found in results. Sample result structure:', aggregatedResults[0]);
        }
        console.log('=== End Test Suite Mapping Debug ===');

        // Build test suite name filter dropdown
        const suiteFilterSelect = document.getElementById('reportSuiteFilterSelect');
        if (suiteFilterSelect) {
            const seen = new Set();
            suiteFilterSelect.innerHTML = '<option value="">All Test Suites</option>';
            
            const suiteNames = Object.keys(suiteNameToIdMap).filter(name => name && name.trim() !== '');
            if (suiteNames.length > 0) {
                suiteNames.sort().forEach(suiteName => {
                    if (seen.has(suiteName)) return;
                    seen.add(suiteName);
                    const opt = document.createElement('option');
                    opt.value = suiteName;
                    opt.textContent = suiteName;
                    suiteFilterSelect.appendChild(opt);
                });
                console.log(`Populated dropdown with ${suiteNames.length} test suite(s)`);
            } else {
                console.warn('No test suite names found to populate dropdown');
            }
        } else {
            console.error('reportSuiteFilterSelect element not found');
        }

        // Build filter dropdown options (Report ID)
        const filterSelect = document.getElementById('reportFilterSelect');
        if (filterSelect) {
            // Keep unique report IDs
            const seen = new Set();
            filterSelect.innerHTML = '<option value="">All Reports</option>';
            window.allReportsMeta.forEach(meta => {
                if (!meta.report_id || seen.has(meta.report_id)) return;
                seen.add(meta.report_id);
                const opt = document.createElement('option');
                opt.value = meta.report_id;
                opt.textContent = meta.report_id;
                filterSelect.appendChild(opt);
            });
        }

        // Store suite mappings globally for filtering
        window.suiteIdToNameMap = suiteIdToNameMap;
        window.suiteNameToIdMap = suiteNameToIdMap;

        // Apply filters if selected
        let visibleResults = aggregatedResults;
        const suiteFilterValue = document.getElementById('reportSuiteFilterSelect')?.value || '';
        const filterValue = document.getElementById('reportFilterSelect')?.value || '';
        
        if (suiteFilterValue) {
            // Filter by test suite name
            const suiteIds = Array.from(suiteNameToIdMap[suiteFilterValue] || []);
            visibleResults = visibleResults.filter(r => {
                const testCaseObj = r.test_case || {};
                const suiteId = testCaseObj.test_suite_id || r.test_suite_id;
                return suiteIds.includes(suiteId);
            });
        }
        
        if (filterValue) {
            // Filter by report ID
            visibleResults = visibleResults.filter(r => (r.test_suite_report_id || testSuiteReportId) === filterValue);
        }

        // Reset sort direction when populating new data
        testCaseIdSortDirection = 'asc';
        const sortIcon = document.getElementById('testCaseIdSortIcon');
        if (sortIcon) {
            sortIcon.className = 'bi bi-arrow-down-up';
        }

        // Store aggregated test results globally for detail modal (before filtering)
        window.testResults = aggregatedResults;

        // Render table with filtered results
        renderTestResultsTable(visibleResults);

        // Update report details (show latest report id and times)
        const detailsSection = document.getElementById('reportDetailsSection');
        if (detailsSection) {
            const reportId = testSuiteReportId || (testResults.length > 0 && testResults[0].test_suite_report_id) || window.currentTestSuiteReportId;
            if (reportId || testResults.length > 0) {
                detailsSection.style.display = 'block';
                if (reportId) {
                    document.getElementById('reportSuiteId').textContent = reportId;
                }

                // Calculate total duration from first and last test
                let totalDuration = '-';
                if (testResults.length > 0) {
                    const firstTest = testResults[0];
                    const lastTest = testResults[testResults.length - 1];
                    if (firstTest.start_time && lastTest.end_time) {
                        try {
                            const start = new Date(firstTest.start_time);
                            const end = new Date(lastTest.end_time);
                            const durationMs = end - start;
                            totalDuration = formatDuration(durationMs);
                        } catch (e) {
                            console.error('Error calculating total duration:', e);
                        }
                    }
                }

                document.getElementById('reportStartTime').textContent = testResults.length > 0 && testResults[0].start_time
                    ? formatDateTime(testResults[0].start_time)
                    : '-';
                document.getElementById('reportEndTime').textContent = testResults.length > 0 && testResults[testResults.length - 1].end_time
                    ? formatDateTime(testResults[testResults.length - 1].end_time)
                    : '-';
                document.getElementById('reportTotalDuration').textContent = totalDuration;

                const successRate = totalTests > 0 ? ((passedTests / totalTests) * 100).toFixed(1) : 0;
                document.getElementById('reportSuccessRate').textContent = successRate + '%';
                // Status shows percentage of Passed tests
                const passedRate = parseFloat(successRate);
                let statusBadgeClass = 'bg-danger';
                if (passedRate === 100) {
                    statusBadgeClass = 'bg-success';
                } else if (passedRate >= 80) {
                    statusBadgeClass = 'bg-info';
                } else if (passedRate >= 50) {
                    statusBadgeClass = 'bg-warning';
                }
                document.getElementById('reportOverallStatus').innerHTML = `<span class="badge ${statusBadgeClass}">${successRate}% Passed</span>`;
            } else {
                detailsSection.style.display = 'none';
            }
        }

        // Update raw data (show aggregated)
        const rawDataEl = document.getElementById('rawReportData');
        if (rawDataEl) {
            rawDataEl.textContent = JSON.stringify({
                reports: window.allReportsMeta,
                test_results: window.allTestResults
            }, null, 2);
        }

        // Scroll to report
        setTimeout(() => {
            const phase5 = document.getElementById('phase5');
            if (phase5) {
                phase5.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }, 100);

        showNotification('success', 'Hoàn thành!', 'Đã lấy report thành công.');
    }

    function getStatusBadge(status) {
        const statusLower = (status || '').toLowerCase();
        if (statusLower === 'passed' || statusLower === 'pass' || statusLower === 'success') {
            return '<span class="badge bg-success">Passed</span>';
        } else if (statusLower === 'failed' || statusLower === 'fail' || statusLower === 'error') {
            return '<span class="badge bg-danger">Failed</span>';
        } else {
            return '<span class="badge bg-warning">Pending</span>';
        }
    }

    function formatDuration(duration) {
        if (!duration || duration === '-') return '-';
        if (typeof duration === 'number') {
            if (duration < 1000) {
                return duration + 'ms';
            } else if (duration < 60000) {
                return (duration / 1000).toFixed(2) + 's';
            } else {
                return (duration / 60000).toFixed(2) + 'm';
            }
        }
        return duration;
    }

    function formatDateTime(dateTime) {
        if (!dateTime || dateTime === '-') return '-';
        try {
            const date = new Date(dateTime);
            return date.toLocaleString('vi-VN', {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });
        } catch (e) {
            return dateTime;
        }
    }

    function getStatusCodeBadgeClass(statusCode) {
        if (!statusCode || statusCode === '-') return 'bg-secondary';
        const code = parseInt(statusCode);
        if (code >= 200 && code < 300) return 'bg-success';
        if (code >= 300 && code < 400) return 'bg-info';
        if (code >= 400 && code < 500) return 'bg-warning';
        if (code >= 500) return 'bg-danger';
        return 'bg-secondary';
    }

    // Sort state for Test Case ID column
    let testCaseIdSortDirection = 'asc'; // 'asc' or 'desc'

    function sortTableByTestCaseId() {
        const tableBody = document.getElementById('testResultsTableBody');
        if (!tableBody) return;

        const rows = Array.from(tableBody.querySelectorAll('tr'));
        if (rows.length === 0) return;

        // Toggle sort direction
        testCaseIdSortDirection = testCaseIdSortDirection === 'asc' ? 'desc' : 'asc';

        // Sort rows by Test Case ID
        rows.sort((a, b) => {
            const aId = a.cells[0].querySelector('code')?.textContent?.trim() || '';
            const bId = b.cells[0].querySelector('code')?.textContent?.trim() || '';

            // Try to compare as numbers if both are numeric
            const aNum = parseFloat(aId);
            const bNum = parseFloat(bId);
            if (!isNaN(aNum) && !isNaN(bNum)) {
                return testCaseIdSortDirection === 'asc' ? aNum - bNum : bNum - aNum;
            }

            // Otherwise compare as strings
            if (testCaseIdSortDirection === 'asc') {
                return aId.localeCompare(bId);
            } else {
                return bId.localeCompare(aId);
            }
        });

        // Clear and re-append sorted rows
        tableBody.innerHTML = '';
        rows.forEach(row => tableBody.appendChild(row));

        // Update sort icon
        const sortIcon = document.getElementById('testCaseIdSortIcon');
        if (sortIcon) {
            if (testCaseIdSortDirection === 'asc') {
                sortIcon.className = 'bi bi-arrow-up';
            } else {
                sortIcon.className = 'bi bi-arrow-down';
            }
        }
    }

    function viewTestResultDetail(index) {
        if (!window.testResults || !window.testResults[index]) {
            showNotification('error', 'Lỗi', 'Không tìm thấy test result');
            return;
        }

        const test = window.testResults[index];
        const status = (test.status || 'pending').toLowerCase();

        // Update modal header color based on status
        const modalHeader = document.querySelector('#testResultDetailModal .modal-header');
        if (modalHeader) {
            // Remove existing background classes
            modalHeader.classList.remove('bg-success', 'bg-danger', 'bg-warning');
            // Add appropriate class based on status
            if (status === 'passed' || status === 'pass') {
                modalHeader.classList.add('bg-success');
            } else if (status === 'failed' || status === 'fail') {
                modalHeader.classList.add('bg-danger');
            } else {
                modalHeader.classList.add('bg-warning');
            }
        }

        // Calculate duration
        let duration = '-';
        if (test.start_time && test.end_time) {
            try {
                const start = new Date(test.start_time);
                const end = new Date(test.end_time);
                const durationMs = end - start;
                duration = formatDuration(durationMs);
            } catch (e) {
                console.error('Error calculating duration:', e);
            }
        }

        // Get test case object
        const testCaseObj = test.test_case || {};
        const testCaseName = testCaseObj.test_case || test.test_case_name || `Test Case ${index + 1}`;
        const testCaseId = testCaseObj.test_case_id || testCaseObj.id || test.test_case_id || test.id || 'N/A';
        const testCaseType = testCaseObj.test_case_type || 'N/A';
        const apiInfo = testCaseObj.api_info || {};
        const endpoint = apiInfo.url || test.endpoint || test.url || 'N/A';
        const method = apiInfo.method || 'N/A';
        const expectedOutput = testCaseObj.expected_output || {};

        // Populate modal
        document.getElementById('resultDetailId').textContent = testCaseId;
        document.getElementById('resultDetailName').textContent = testCaseName;
        document.getElementById('resultDetailEndpoint').textContent = endpoint;
        document.getElementById('resultDetailStatus').innerHTML = getStatusBadge(status);
        document.getElementById('resultDetailResponseCode').innerHTML = `<span class="badge ${getStatusCodeBadgeClass(test.response_status_code)}">${test.response_status_code || 'N/A'}</span>`;
        document.getElementById('resultDetailDuration').textContent = duration;
        document.getElementById('resultDetailStartTime').textContent = formatDateTime(test.start_time);
        document.getElementById('resultDetailExecutedAt').textContent = formatDateTime(test.end_time || test.start_time);

        // Update additional fields if they exist in the modal
        const resultDetailMethod = document.getElementById('resultDetailMethod');
        if (resultDetailMethod) {
            resultDetailMethod.textContent = method;
        }
        const resultDetailTestCaseType = document.getElementById('resultDetailTestCaseType');
        if (resultDetailTestCaseType) {
            resultDetailTestCaseType.textContent = testCaseType;
        }
        const resultDetailExpectedOutput = document.getElementById('resultDetailExpectedOutput');
        if (resultDetailExpectedOutput) {
            resultDetailExpectedOutput.textContent = Object.keys(expectedOutput).length > 0
                ? JSON.stringify(expectedOutput, null, 2)
                : 'N/A';
        }

        // Request Body
        const requestBody = test.request_body || {};

        // Request Headers - populate into expander
        const requestHeader = test.request_header || {};
        const requestHeadersElement = document.getElementById('resultDetailRequestHeaders');
        if (requestHeadersElement) {
            requestHeadersElement.textContent = Object.keys(requestHeader).length > 0
                ? JSON.stringify(requestHeader, null, 2)
                : '(empty)';
        }

        // Request Body - only show body, no method/url/headers
        let requestInfo = '';
        if (Object.keys(requestBody).length > 0) {
            requestInfo = JSON.stringify(requestBody, null, 2);
        } else {
            requestInfo = '(empty)';
        }
        document.getElementById('resultDetailRequest').textContent = requestInfo;

        // Response Body
        const responseBody = test.response_body || {};

        // Response Headers - populate into expander
        const responseHeader = test.response_header || {};
        const responseHeadersElement = document.getElementById('resultDetailResponseHeaders');
        if (responseHeadersElement) {
            responseHeadersElement.textContent = Object.keys(responseHeader).length > 0
                ? JSON.stringify(responseHeader, null, 2)
                : '(empty)';
        }

        // Response Body - only show body, no headers
        let responseInfo = '';
        if (Object.keys(responseBody).length > 0) {
            responseInfo = JSON.stringify(responseBody, null, 2);
        } else {
            responseInfo = '(empty)';
        }
        document.getElementById('resultDetailResponse').textContent = responseInfo;

        // Error section - show if status is failed
        const errorSection = document.getElementById('resultDetailErrorSection');
        if (status === 'failed' || status === 'fail') {
            errorSection.style.display = 'block';
            let errorMessage = `Test failed with status code: ${test.response_status_code || 'N/A'}`;
            if (test.error || test.error_message) {
                errorMessage += '\n\n' + (test.error || test.error_message);
            }
            document.getElementById('resultDetailError').textContent = errorMessage;
        } else {
            errorSection.style.display = 'none';
        }

        // Show modal
        const modal = new bootstrap.Modal(document.getElementById('testResultDetailModal'));
        modal.show();
    }

    function filterReportBySuiteName(suiteName) {
        // Use window.testResults if available, otherwise use window.allTestResults
        const allResults = window.testResults || window.allTestResults || [];
        
        if (!allResults || allResults.length === 0) {
            console.warn('No test results available for filtering');
            return;
        }

        // Get suite IDs for this suite name
        const suiteIds = suiteName && window.suiteNameToIdMap && window.suiteNameToIdMap[suiteName]
            ? Array.from(window.suiteNameToIdMap[suiteName])
            : null;

        // Apply filters - start with all results
        let visibleResults = allResults;
        
        // Filter by test suite name (only if suiteName is provided and not empty)
        if (suiteName && suiteIds && suiteIds.length > 0) {
            visibleResults = visibleResults.filter(r => {
                const testCaseObj = r.test_case || {};
                const suiteId = testCaseObj.test_suite_id || r.test_suite_id || r.test_suite?.id;
                return suiteIds.includes(suiteId);
            });
        }

        // Also apply report ID filter if selected
        const reportFilterValue = document.getElementById('reportFilterSelect')?.value || '';
        if (reportFilterValue) {
            visibleResults = visibleResults.filter(r => 
                (r.test_suite_report_id || window.currentTestSuiteReportId) === reportFilterValue
            );
        }

        // Re-render table with filtered results
        renderTestResultsTable(visibleResults);
    }

    function filterReportById(reportId) {
        if (!window.allTestResults || window.allTestResults.length === 0) {
            return;
        }

        // Apply filters
        let visibleResults = window.allTestResults;
        
        // Filter by report ID
        if (reportId) {
            visibleResults = visibleResults.filter(r => 
                (r.test_suite_report_id || window.currentTestSuiteReportId) === reportId
            );
        }

        // Also apply test suite name filter if selected
        const suiteFilterValue = document.getElementById('reportSuiteFilterSelect')?.value || '';
        if (suiteFilterValue && window.suiteNameToIdMap && window.suiteNameToIdMap[suiteFilterValue]) {
            const suiteIds = Array.from(window.suiteNameToIdMap[suiteFilterValue]);
            visibleResults = visibleResults.filter(r => {
                const testCaseObj = r.test_case || {};
                const suiteId = testCaseObj.test_suite_id || r.test_suite_id;
                return suiteIds.includes(suiteId);
            });
        }

        // Re-render table with filtered results
        renderTestResultsTable(visibleResults);
    }

    function renderTestResultsTable(visibleResults) {
        const tableBody = document.getElementById('testResultsTableBody');
        const emptyState = document.getElementById('reportEmptyState');

        if (!tableBody) return;

        tableBody.innerHTML = '';

        if (visibleResults.length === 0) {
            if (emptyState) emptyState.style.display = 'block';
            // Update statistics to 0
            document.getElementById('totalTestsCount').textContent = '0';
            document.getElementById('passedTestsCount').textContent = '0';
            document.getElementById('failedTestsCount').textContent = '0';
            document.getElementById('pendingTestsCount').textContent = '0';
            return;
        }

        if (emptyState) emptyState.style.display = 'none';

        // Calculate statistics
        let totalTests = visibleResults.length;
        let passedTests = 0;
        let failedTests = 0;
        let pendingTests = 0;

        visibleResults.forEach(test => {
            const status = (test.status || 'pending').toLowerCase();
            if (status === 'passed' || status === 'pass') {
                passedTests++;
            } else if (status === 'failed' || status === 'fail') {
                failedTests++;
            } else {
                pendingTests++;
            }
        });

        // Update summary statistics
        document.getElementById('totalTestsCount').textContent = totalTests;
        document.getElementById('passedTestsCount').textContent = passedTests;
        document.getElementById('failedTestsCount').textContent = failedTests;
        document.getElementById('pendingTestsCount').textContent = pendingTests;

        // Store filtered results for detail modal (use original index from allTestResults)
        const filteredIndices = [];
        visibleResults.forEach((test, idx) => {
            const originalIndex = window.allTestResults.findIndex(t => t === test);
            filteredIndices.push(originalIndex >= 0 ? originalIndex : idx);
        });

        // Render table rows
        visibleResults.forEach((test, index) => {
            const status = (test.status || 'pending').toLowerCase();
            const statusBadge = getStatusBadge(status);
            const responseCode = test.response_status_code || '-';

            // Calculate duration from start_time and end_time
            let duration = '-';
            if (test.start_time && test.end_time) {
                try {
                    const start = new Date(test.start_time);
                    const end = new Date(test.end_time);
                    const durationMs = end - start;
                    duration = formatDuration(durationMs);
                } catch (e) {
                    console.error('Error calculating duration:', e);
                }
            }

            // Get test case info from nested test_case object
            const testCaseObj = test.test_case || {};
            const testCaseName = testCaseObj.test_case || test.test_case_name || `Test Case ${index + 1}`;
            const testCaseId = testCaseObj.test_case_id || testCaseObj.id || test.test_case_id || test.id || '-';

            // Get endpoint from test_case.api_info.url
            const endpoint = testCaseObj.api_info?.url || test.endpoint || test.url || 'N/A';

            const row = document.createElement('tr');
            const originalIndex = filteredIndices[index];
            row.innerHTML = `
                <td><code class="small">${testCaseId}</code></td>
                <td>${testCaseName}</td>
                <td>${statusBadge}</td>
                <td><span class="badge ${getStatusCodeBadgeClass(responseCode)}">${responseCode}</span></td>
                <td>
                    <button class="btn btn-sm btn-outline-primary" onclick="viewTestResultDetail(${originalIndex})" title="View Details">
                        <i class="bi bi-eye"></i>
                    </button>
                </td>
            `;
            tableBody.appendChild(row);
        });
    }

    function refreshReport() {
        if (!window.currentTestSuiteReportId || !window.currentProjectUuid) {
            showNotification('warning', 'Cảnh báo', 'Không có report để refresh.');
            return;
        }

        const refreshBtn = document.getElementById('refreshReportBtn');
        if (refreshBtn) {
            refreshBtn.disabled = true;
            refreshBtn.innerHTML = '<i class="bi bi-arrow-clockwise spin"></i> Refreshing...';
        }

        // Don't show loading page, just show notification
        // showReportLoading is removed - we don't need loading page for refresh

        fetch(`/project/${window.currentProjectUuid}/test-report/${window.currentTestSuiteReportId}/`, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
            },
            _timeoutMs: 10000,
            _retries: 1
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    displayTestReport(data, window.currentTestSuiteReportId);
                    showNotification('success', 'Thành công', 'Đã làm mới report.');
                } else {
                    showNotification('error', 'Lỗi!', data.message || 'Không thể làm mới report.');
                    hideReportLoading();
                }
            })
            .catch(error => {
                console.error('Error refreshing report:', error);
                showNotification('error', 'Lỗi!', 'Đã xảy ra lỗi khi làm mới report.');
                hideReportLoading();
            })
            .finally(() => {
                if (refreshBtn) {
                    refreshBtn.disabled = false;
                    refreshBtn.innerHTML = '<i class="bi bi-arrow-clockwise"></i> Refresh';
                }
            });
    }

    function exportReport() {
        if (!window.currentReportData) {
            showNotification('warning', 'Cảnh báo', 'Không có dữ liệu để export.');
            return;
        }

        const dataStr = JSON.stringify(window.currentReportData, null, 2);
        const dataBlob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(dataBlob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `test-report-${window.currentTestSuiteReportId || Date.now()}.json`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);

        showNotification('success', 'Thành công', 'Đã export report.');
    }

    function viewTestCaseDetails(index, testCaseId) {
        // Try to find test case from filtered list first, then from all test cases
        let testCase = null;
        
        if (filteredTestCases.length > 0 && index < filteredTestCases.length) {
            testCase = filteredTestCases[index];
        } else if (testCaseId) {
            // Find by ID from all test cases
            testCase = allTestCases.find(tc => {
                const id = getTestCaseId(tc);
                return id === testCaseId;
            });
        } else if (index < allTestCases.length) {
            // Fallback to allTestCases by index
            testCase = allTestCases[index];
        }
        
        if (!testCase) {
            showNotification('error', 'Lỗi', 'Không tìm thấy test case');
            return;
        }

        // Populate modal with test case details
        document.getElementById('testCaseDetailId').textContent = testCase.test_case_id || 'N/A';
        document.getElementById('testCaseDetailName').textContent = testCase.test_case_name || 'N/A';
        document.getElementById('testCaseDetailEndpoint').textContent = testCase.endpoint || 'N/A';
        document.getElementById('testCaseDetailCategory').textContent = testCase.test_category || 'N/A';
        document.getElementById('testCaseDetailStatus').textContent = testCase.expected_statuscode || 'N/A';

        // Get method from api_info.method or http_method
        const method = testCase.api_info?.method || testCase.http_method || 'N/A';
        const methodElement = document.getElementById('testCaseDetailMethod');
        methodElement.textContent = method;

        // Set badge color based on HTTP method
        const methodUpper = method.toUpperCase();
        methodElement.classList.remove('bg-info', 'bg-primary', 'bg-success', 'bg-warning', 'bg-danger', 'bg-secondary');
        if (methodUpper === 'GET') {
            methodElement.classList.add('bg-primary');
        } else if (methodUpper === 'POST') {
            methodElement.classList.add('bg-success');
        } else if (methodUpper === 'PUT' || methodUpper === 'PATCH') {
            methodElement.classList.add('bg-warning');
        } else if (methodUpper === 'DELETE') {
            methodElement.classList.add('bg-danger');
        } else {
            methodElement.classList.add('bg-secondary');
        }

        // Format and display headers
        const header = testCase.header || {};
        const headerElement = document.getElementById('testCaseDetailHeader');
        if (header && typeof header === 'object' && Object.keys(header).length > 0) {
            try {
                const formatted = JSON.stringify(header, null, 2);
                headerElement.textContent = formatted;
                headerElement.className = 'bg-light p-3 rounded border mb-0';
            } catch (e) {
                headerElement.textContent = JSON.stringify(header, null, 2);
                headerElement.className = 'bg-light p-3 rounded border mb-0';
            }
        } else if (header && typeof header === 'string') {
            try {
                const headerObj = JSON.parse(header);
                const formatted = JSON.stringify(headerObj, null, 2);
                headerElement.textContent = formatted;
                headerElement.className = 'bg-light p-3 rounded border mb-0';
            } catch (e) {
                headerElement.textContent = header;
                headerElement.className = 'bg-light p-3 rounded border mb-0';
            }
        } else {
            headerElement.textContent = 'N/A';
            headerElement.className = 'text-muted mb-0';
        }

        // Format and display request body
        const requestBody = testCase.request_body || 'N/A';
        const requestBodyElement = document.getElementById('testCaseDetailRequestBody');
        if (requestBody !== 'N/A') {
            try {
                const formatted = JSON.stringify(JSON.parse(requestBody), null, 2);
                requestBodyElement.textContent = formatted;
                requestBodyElement.className = 'bg-light p-3 rounded border';
            } catch (e) {
                requestBodyElement.textContent = requestBody;
                requestBodyElement.className = 'bg-light p-3 rounded border';
            }
        } else {
            requestBodyElement.textContent = 'N/A';
            requestBodyElement.className = 'text-muted';
        }

        // Format and display expected response
        const expectedResponse = testCase.expected_response || 'N/A';
        const expectedResponseElement = document.getElementById('testCaseDetailExpectedResponse');
        if (expectedResponse !== 'N/A') {
            try {
                const formatted = JSON.stringify(JSON.parse(expectedResponse), null, 2);
                expectedResponseElement.textContent = formatted;
                expectedResponseElement.className = 'bg-light p-3 rounded border';
            } catch (e) {
                expectedResponseElement.textContent = expectedResponse;
                expectedResponseElement.className = 'bg-light p-3 rounded border';
            }
        } else {
            expectedResponseElement.textContent = 'N/A';
            expectedResponseElement.className = 'text-muted';
        }

        // Hide cURL section initially
        document.getElementById('curlCommandSection').style.display = 'none';

        // Store current test case ID and object for cURL conversion
        window.currentTestCaseIndex = index;
        window.currentTestCaseId = testCaseId || getTestCaseId(testCase);
        window.currentTestCaseObject = testCase;

        // Show modal
        const modal = new bootstrap.Modal(document.getElementById('testCaseDetailModal'));
        modal.show();
    }

    // Store current test case for cURL conversion
    let currentTestCaseForCurl = null;

    function convertToCurl() {
        // Get current test case from stored object, or find by ID/index
        let testCase = window.currentTestCaseObject;
        
        if (!testCase) {
            // Try to find by ID first
            const testCaseId = window.currentTestCaseId;
            if (testCaseId) {
                testCase = allTestCases.find(tc => {
                    const id = getTestCaseId(tc);
                    return id === testCaseId;
                });
            }
            
            // Fallback to index
            if (!testCase) {
                const index = window.currentTestCaseIndex;
                if (index !== undefined && index < allTestCases.length) {
                    testCase = allTestCases[index];
                }
            }
        }
        
        if (!testCase) {
            showNotification('error', 'Lỗi', 'Không tìm thấy test case để convert');
            return;
        }

        currentTestCaseForCurl = testCase;

        // Get data from test case
        let endpoint = testCase.endpoint || '';
        let method = testCase.http_method || 'GET'; // Default to GET if not specified

        // If method is not provided, try to infer from endpoint or API name
        if (!method || method === 'N/A') {
            const apiName = (testCase.api_name || '').toLowerCase();
            const endpointLower = endpoint.toLowerCase();

            if (apiName.includes('create') || apiName.includes('add') || endpointLower.includes('create') || endpointLower.includes('add')) {
                method = 'POST';
            } else if (apiName.includes('update') || apiName.includes('edit') || endpointLower.includes('update') || endpointLower.includes('edit')) {
                method = 'PUT';
            } else if (apiName.includes('delete') || apiName.includes('remove') || endpointLower.includes('delete') || endpointLower.includes('remove')) {
                method = 'DELETE';
            } else {
                method = 'GET';
            }
        }

        const headers = testCase.header || {};
        let requestBody = testCase.request_body || null;

        // Get request_mapping from full_test_case_data if available (for URL placeholder replacement)
        let requestMapping = {};
        if (testCase.full_test_case_data && testCase.full_test_case_data.request_mapping) {
            requestMapping = testCase.full_test_case_data.request_mapping;
        }

        // Replace URL placeholders (e.g., {project_id}) with values from request_mapping
        if (endpoint && endpoint !== 'N/A') {
            // Find all placeholders in URL (format: {placeholder_name})
            const placeholderRegex = /\{(\w+)\}/g;
            let match;
            const placeholders = [];
            while ((match = placeholderRegex.exec(endpoint)) !== null) {
                placeholders.push(match[1]);
            }

            // Replace each placeholder
            placeholders.forEach(placeholderName => {
                const placeholderValue = requestMapping[placeholderName];

                if (placeholderValue !== undefined && placeholderValue !== null) {
                    // Replace placeholder with actual value
                    // Handle special test values
                    let replacementValue = placeholderValue;

                    if (typeof replacementValue === 'string') {
                        // For special test values, use a descriptive placeholder
                        if (replacementValue === 'ABSENT' || replacementValue === 'NULL' || replacementValue === 'N/A') {
                            replacementValue = `{${placeholderName}}`; // Keep placeholder for invalid values
                        } else if (replacementValue.startsWith('CHARS(')) {
                            // Extract length if possible, otherwise keep placeholder
                            const charsMatch = replacementValue.match(/CHARS\((\d+)\)/);
                            if (charsMatch) {
                                replacementValue = `{${placeholderName}}`; // Keep placeholder for generated strings
                            } else {
                                replacementValue = `{${placeholderName}}`;
                            }
                        } else {
                            // Use the actual value (could be UUID, ID, etc.)
                            replacementValue = String(replacementValue);
                        }
                    } else {
                        // Convert non-string to string
                        replacementValue = String(replacementValue);
                    }

                    // Replace all occurrences of this placeholder
                    endpoint = endpoint.replace(new RegExp(`\\{${placeholderName}\\}`, 'g'), replacementValue);
                }
            })
        }

        // Validate endpoint
        if (!endpoint || endpoint === 'N/A') {
            showNotification('error', 'Lỗi', 'Endpoint không hợp lệ, không thể tạo cURL command');
            return;
        }

        // Build cURL command
        let curlCommand = 'curl';

        // Add method
        if (method.toUpperCase() !== 'GET') {
            curlCommand += ` -X ${method.toUpperCase()}`;
        }

        // Add headers
        let hasContentType = false;
        if (headers && typeof headers === 'object' && Object.keys(headers).length > 0) {
            Object.entries(headers).forEach(([key, value]) => {
                if (key.toLowerCase() === 'content-type') {
                    hasContentType = true;
                }
                // Escape special characters in header values
                const escapedValue = String(value).replace(/"/g, '\\"');
                curlCommand += ` \\\n  -H "${key}: ${escapedValue}"`;
            });
        } else if (headers && typeof headers === 'string') {
            try {
                const headerObj = JSON.parse(headers);
                Object.entries(headerObj).forEach(([key, value]) => {
                    if (key.toLowerCase() === 'content-type') {
                        hasContentType = true;
                    }
                    const escapedValue = String(value).replace(/"/g, '\\"');
                    curlCommand += ` \\\n  -H "${key}: ${escapedValue}"`;
                });
            } catch (e) {
                // If parsing fails, skip headers
            }
        }

        // Add Content-Type header if not present and we have a body
        if (!hasContentType && requestBody && requestBody !== 'N/A' && ['POST', 'PUT', 'PATCH'].includes(method.toUpperCase())) {
            curlCommand += ` \\\n  -H "Content-Type: application/json"`;
        }

        // Add request body for POST, PUT, PATCH methods
        if (requestBody && requestBody !== 'N/A' && ['POST', 'PUT', 'PATCH'].includes(method.toUpperCase())) {
            try {
                // Try to parse as JSON to ensure it's valid
                let bodyStr;
                if (typeof requestBody === 'string') {
                    // Try to parse as JSON
                    try {
                        const bodyObj = JSON.parse(requestBody);
                        bodyStr = JSON.stringify(bodyObj);
                    } catch (e) {
                        // If not valid JSON, use as is
                        bodyStr = requestBody;
                    }
                } else {
                    bodyStr = JSON.stringify(requestBody);
                }

                // Escape for shell: escape single quotes and backslashes
                const escapedBody = bodyStr
                    .replace(/\\/g, '\\\\')  // Escape backslashes first
                    .replace(/'/g, "'\\''")  // Escape single quotes
                    .replace(/\n/g, '\\n')    // Escape newlines
                    .replace(/\r/g, '\\r');    // Escape carriage returns

                curlCommand += ` \\\n  -d '${escapedBody}'`;
            } catch (e) {
                // If not JSON, treat as plain text
                const escapedBody = String(requestBody)
                    .replace(/\\/g, '\\\\')
                    .replace(/'/g, "'\\''")
                    .replace(/\n/g, '\\n')
                    .replace(/\r/g, '\\r');
                curlCommand += ` \\\n  -d '${escapedBody}'`;
            }
        }

        // Add URL (must be last or properly quoted)
        // Escape special characters in URL
        const escapedUrl = endpoint.replace(/"/g, '\\"');
        curlCommand += ` \\\n  "${escapedUrl}"`;

        // Display cURL command
        const curlElement = document.getElementById('testCaseDetailCurl');
        curlElement.textContent = curlCommand;

        // Show cURL section
        document.getElementById('curlCommandSection').style.display = 'block';

        // Scroll to cURL section
        setTimeout(() => {
            document.getElementById('curlCommandSection').scrollIntoView({
                behavior: 'smooth',
                block: 'nearest'
            });
        }, 100);

        showNotification('success', 'Thành công!', 'Đã convert test case sang cURL command');
    }

    function copyCurlCommand() {
        const curlElement = document.getElementById('testCaseDetailCurl');
        const curlCommand = curlElement.textContent;

        if (!curlCommand || curlCommand === '-') {
            showNotification('error', 'Lỗi', 'Không có cURL command để copy');
            return;
        }

        // Copy to clipboard
        navigator.clipboard.writeText(curlCommand).then(() => {
            // Update button to show success
            const copyBtn = document.getElementById('copyCurlBtn');
            const originalHtml = copyBtn.innerHTML;
            copyBtn.innerHTML = '<i class="bi bi-check"></i> Copied!';
            copyBtn.classList.remove('btn-outline-primary');
            copyBtn.classList.add('btn-success');

            showNotification('success', 'Đã copy!', 'cURL command đã được copy vào clipboard');

            // Reset button after 2 seconds
            setTimeout(() => {
                copyBtn.innerHTML = originalHtml;
                copyBtn.classList.remove('btn-success');
                copyBtn.classList.add('btn-outline-primary');
            }, 2000);
        }).catch(err => {
            console.error('Failed to copy:', err);
            showNotification('error', 'Lỗi', 'Không thể copy cURL command');
        });
    }

    function loadSections() {
        // Load sections from all completed documents
        fetch(`/project/{{ project.uuid }}/sections/json/`, { _noLoading: true, _timeoutMs: 30000, _retries: 1 })
            .then(response => response.json())
            .then(data => {
                if (data.success && data.sections.length > 0) {
                    const container = document.getElementById('sectionsContainer');
                    container.innerHTML = `
                <div class="alert alert-info mb-3">
                    <i class="bi bi-info-circle"></i>
                    <strong>${data.total_sections || data.sections.length} sections</strong> extracted from <strong>${data.documents_count || 'all processed'} documents</strong>.
                </div>
                <div class="row"></div>
            `;
                    const row = container.querySelector('.row');

                    data.sections.forEach(section => {
                        const sectionCard = createSectionCard(section);
                        row.appendChild(sectionCard);
                    });

                    // Hide sections and show FR annotations instead
                    document.getElementById('sectionsContainer').style.display = 'none';

                    // Reset the first load flag to ensure analyze=true for fresh data when coming from step 2
                    localStorage.removeItem('fr_first_load_done');

                    // Load FR annotations after sections
                    loadFRAnnotations();
                } else {
                    document.getElementById('sectionsContainer').innerHTML = `
                <div class="text-center py-5">
                    <i class="bi bi-inbox" style="font-size: 3rem; color: #6c757d;"></i>
                    <h5 class="mt-3 text-muted">No sections found</h5>
                    <p class="text-muted">AI processing may not have extracted any sections from the uploaded documents.</p>
                    <button class="btn btn-sm btn-outline-secondary mt-3" onclick="loadSections()">
                        <i class="bi bi-arrow-clockwise"></i> Thử lại
                    </button>
                </div>
            `;
                }
            })
            .catch(error => {
                console.error('Error loading sections:', error);
                document.getElementById('sectionsContainer').innerHTML = `
            <div class="text-center py-5">
                <i class="bi bi-exclamation-triangle" style="font-size: 3rem; color: #dc3545;"></i>
                <h5 class="mt-3 text-muted">Error loading sections</h5>
                <p class="text-muted">An error occurred while loading sections: ${error.message}</p>
                <button class="btn btn-primary mt-3" onclick="loadSections()">
                    <i class="bi bi-arrow-clockwise"></i> Thử lại
                </button>
            </div>
        `;
            });
    }

    function loadFRAnnotations(analyzeOverride = null) {
        const frList = document.getElementById('frList');
        if (!frList) return;

        // Show loading state
        frList.innerHTML = `
        <div class="col-12">
            <div class="text-center py-4">
                <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Loading...</span>
                </div>
                <p class="mt-2 text-muted">Loading Functional Requirements...</p>
            </div>
        </div>
    `;

        // Determine analyze parameter
        // Default to cached mode since FR extraction is now done in step 2
        let analyze = false;

        // Check saved preference from toggle (if user wants to re-analyze)
        const savedPreference = localStorage.getItem('fr_analyze_preference');
        if (savedPreference !== null) {
            analyze = JSON.parse(savedPreference);
        }

        // Call the backend API endpoint
        const apiUrl = `/project/{{ project.uuid }}/annotate-fr/`;

        console.log('Loading FR annotations with analyze=', analyze);

        fetch(apiUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value,
                'accept': 'application/json'
            },
            body: JSON.stringify({
                lang: 'vi',
                analyze: analyze
            }),
            _timeoutMs: 60000,
            _retries: 1
        })
            .then(response => {
                console.log('FR API response status:', response.status);
                return response.json();
            })
            .then(data => {
                console.log('FR API response data:', data);

                // Handle both wrapped response (success: true, fr_annotations: [...]) and direct array response
                let frArray = [];
                if (data.success && data.fr_annotations && Array.isArray(data.fr_annotations)) {
                    frArray = data.fr_annotations;
                    // Show cache status if applicable
                    if (data.cached) {
                        const cacheAlert = document.createElement('div');
                        cacheAlert.className = 'alert alert-info alert-dismissible fade show mb-3';
                        cacheAlert.innerHTML = `
                    <i class="bi bi-info-circle"></i>
                    <strong>Using cached data.</strong> Toggle "Fresh" and reload to re-analyze documents.
                    <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
                `;
                        frList.appendChild(cacheAlert);
                    }
                } else if (Array.isArray(data)) {
                    // Direct array response from API
                    frArray = data;
                }

                if (frArray.length > 0) {
                    // Show the FR container
                    document.getElementById('frContainer').style.display = 'block';
                    document.getElementById('sectionsContainer').style.display = 'none';

                    frList.innerHTML = '';

                    frArray.forEach(fr => {
                        const col = document.createElement('div');
                        col.className = 'col-md-6 col-lg-4 mb-3';

                        const card = document.createElement('div');
                        card.className = 'card h-100 border';

                        const cardBody = document.createElement('div');
                        cardBody.className = 'card-body d-flex flex-column';

                        // Checkbox
                        const checkboxDiv = document.createElement('div');
                        checkboxDiv.className = 'form-check mb-2';

                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.className = 'form-check-input fr-checkbox';
                        checkbox.value = fr.fr_info_id;
                        checkbox.id = `fr_${fr.fr_info_id}`;
                        // Restore selection state from cached data
                        checkbox.checked = fr.is_selected || false;

                        const checkboxLabel = document.createElement('label');
                        checkboxLabel.className = 'form-check-label fw-bold';
                        checkboxLabel.htmlFor = `fr_${fr.fr_info_id}`;
                        checkboxLabel.textContent = fr.fr_group;

                        checkboxDiv.appendChild(checkbox);
                        checkboxDiv.appendChild(checkboxLabel);

                        // Description
                        const description = document.createElement('p');
                        description.className = 'card-text text-muted small flex-grow-1';
                        description.textContent = fr.description || 'No description available';

                        // Document locations
                        if (fr.documents && fr.documents.length > 0) {
                            const docInfo = document.createElement('div');
                            docInfo.className = 'mt-2';
                            fr.documents.forEach(doc => {
                                const docBadge = document.createElement('span');
                                docBadge.className = 'badge bg-info me-1 mb-1';
                                docBadge.textContent = `Doc ${doc.doc}, §${doc.heading}`;
                                docInfo.appendChild(docBadge);
                            });
                            cardBody.appendChild(docInfo);
                        }

                        // Info row
                        const infoRow = document.createElement('div');
                        infoRow.className = 'mt-auto';
                        infoRow.appendChild(description);

                        // Controls row
                        const controlsRow = document.createElement('div');
                        controlsRow.className = 'd-flex justify-content-between align-items-center mt-2';

                        const frId = document.createElement('small');
                        frId.className = 'text-muted';
                        frId.textContent = `ID: ${fr.fr_info_id}`;

                        const controlsRight = document.createElement('div');
                        controlsRight.className = 'd-flex align-items-center gap-2';

                        const statusBadge = document.createElement('span');
                        statusBadge.className = `badge ${fr.is_selected ? 'bg-success' : 'bg-secondary'}`;
                        statusBadge.textContent = fr.is_selected ? 'Selected' : 'Not Selected';

                        // const viewDetailsBtn = document.createElement('button');
                        // viewDetailsBtn.className = 'btn btn-sm btn-outline-info';
                        // viewDetailsBtn.innerHTML = '<i class="bi bi-eye"></i>';
                        // viewDetailsBtn.title = 'View FR Details';
                        // viewDetailsBtn.onclick = () => showFRDetails(fr, fr.fr_info_id);

                        controlsRight.appendChild(statusBadge);
                        // controlsRight.appendChild(viewDetailsBtn);

                        controlsRow.appendChild(frId);
                        controlsRow.appendChild(controlsRight);

                        cardBody.appendChild(checkboxDiv);
                        cardBody.appendChild(infoRow);
                        cardBody.appendChild(controlsRow);
                        card.appendChild(cardBody);
                        col.appendChild(card);

                        frList.appendChild(col);
                    });

                    // Add event listeners to save FR selection immediately when checkboxes change
                    document.querySelectorAll('.fr-checkbox').forEach(checkbox => {
                        checkbox.addEventListener('change', function () {
                            const frId = this.value;
                            const isSelected = this.checked;
                            const badge = this.closest('.card-body').querySelector('.badge');

                            // Update badge immediately for better UX
                            if (badge) {
                                if (isSelected) {
                                    badge.className = 'badge bg-success';
                                    badge.textContent = 'Selected';
                                } else {
                                    badge.className = 'badge bg-secondary';
                                    badge.textContent = 'Not Selected';
                                }
                            }

                            // Save selection immediately
                            saveSingleFRSelection(frId, isSelected);
                        });
                    });

                    // Check if any FRs are already selected
                    const hasSelectedFRs = frArray.some(fr => fr.is_selected === true);

                    // Set flag if FRs are already selected
                    if (hasSelectedFRs) {
                        window.frSelectionsSaved = true;
                        // Cập nhật lock status cho các step
                        updateStepLocks();
                    }

                    // Hide the Save button since selections are saved automatically
                    document.getElementById('saveFRSelectionContainer').style.display = 'none';
                } else {
                    frList.innerHTML = `
                <div class="col-12">
                    <div class="alert alert-danger">
                        <i class="bi bi-exclamation-triangle"></i> ${data.message || 'Error loading Functional Requirements.'}
                    </div>
                </div>
            `;
                }
            })
            .catch(error => {
                console.error('Error loading FR annotations:', error);
                frList.innerHTML = `
            <div class="col-12">
                <div class="alert alert-danger">
                    <i class="bi bi-exclamation-triangle"></i> Failed to load Functional Requirements: ${error.message}
                </div>
            </div>
        `;
            });
    }


    function updateAnalyzeLabel() {
        const toggle = document.getElementById('analyzeToggle');
        const label = document.getElementById('analyzeLabel');
        if (toggle && label) {
            label.textContent = toggle.checked ? 'Fresh' : 'Cached';
            // Save preference to localStorage
            localStorage.setItem('fr_analyze_preference', toggle.checked);

            // Show/hide refresh button based on toggle state
            if (refreshBtn) {
                refreshBtn.style.display = toggle.checked ? 'inline-block' : 'none';
            }
        }
    }

    function loadAnalyzePreference() {
        const toggle = document.getElementById('analyzeToggle');
        if (toggle) {
            // Load from localStorage, default to false (cached mode) for performance
            const savedPreference = localStorage.getItem('fr_analyze_preference');
            toggle.checked = savedPreference !== null ? JSON.parse(savedPreference) : false;
            updateAnalyzeLabel();
        }
    }

    // Set up analyze toggle event listener
    document.addEventListener('DOMContentLoaded', function () {
        const analyzeToggle = document.getElementById('analyzeToggle');
        if (analyzeToggle) {
            analyzeToggle.addEventListener('change', updateAnalyzeLabel);
            loadAnalyzePreference(); // Load saved preference
        }
    });

    function reloadFRs() {
        // Get current toggle state
        const analyzeToggle = document.getElementById('analyzeToggle');
        const shouldAnalyze = analyzeToggle ? analyzeToggle.checked : false;

        // Reload FRs with current analyze setting
        loadFRAnnotations(shouldAnalyze);
    }


    // Function to save a single FR selection immediately
    function saveSingleFRSelection(frId, isSelected) {
        console.log(`Saving FR selection: ${frId}, isSelected: ${isSelected}`);

        fetch(`/project/{{ project.uuid }}/select-fr/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value,
                'accept': 'application/json'
            },
            body: JSON.stringify({
                fr_info_ids: [frId],
                is_selected: isSelected
            }),
            _noLoading: true,  // Bỏ qua loading overlay để không gây khó chịu
            _timeoutMs: 30000,
            _retries: 1
        })
            .then(response => {
                console.log('API response status:', response.status);
                return response.json();
            })
            .then(data => {
                console.log('API response data:', data);
                if (data.success) {
                    // Mark that selections have been saved
                    window.frSelectionsSaved = true;
                    // Cập nhật lock status cho các step
                    updateStepLocks();

                    // Ensure cached data is marked as fresh after saving selections
                    localStorage.setItem('fr_cache_fresh', Date.now().toString());
                } else {
                    // Revert checkbox state on error
                    const checkbox = document.getElementById(`fr_${frId}`);
                    if (checkbox) {
                        checkbox.checked = !isSelected;
                        const badge = checkbox.closest('.card-body').querySelector('.badge');
                        if (badge) {
                            badge.className = `badge ${!isSelected ? 'bg-success' : 'bg-secondary'}`;
                            badge.textContent = !isSelected ? 'Selected' : 'Not Selected';
                        }
                    }
                    showNotification('error', 'Lỗi!', data.message || 'Không thể lưu lựa chọn FR.');
                }
            })
            .catch(error => {
                console.error('Error saving FR selection:', error);
                // Revert checkbox state on error
                const checkbox = document.getElementById(`fr_${frId}`);
                if (checkbox) {
                    checkbox.checked = !isSelected;
                    const badge = checkbox.closest('.card-body').querySelector('.badge');
                    if (badge) {
                        badge.className = `badge ${!isSelected ? 'bg-success' : 'bg-secondary'}`;
                        badge.textContent = !isSelected ? 'Selected' : 'Not Selected';
                    }
                }
                showNotification('error', 'Lỗi!', 'Đã xảy ra lỗi khi lưu lựa chọn FR.');
            });
    }

    function saveFRSelections() {
        const selectedFRs = Array.from(document.querySelectorAll('.fr-checkbox:checked'))
            .map(checkbox => checkbox.value);

        if (selectedFRs.length === 0) {
            alert('Vui lòng chọn ít nhất một Functional Requirement');
            return;
        }

        const button = document.getElementById('saveFRSelectionContainer').querySelector('button');
        const originalText = button.innerHTML;
        button.innerHTML = '<i class="bi bi-hourglass-split"></i> Saving...';
        button.disabled = true;

        // Call the backend select API with all selected FRs
        console.log('Saving FR selections:', selectedFRs);
        fetch(`/project/{{ project.uuid }}/select-fr/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value,
                'accept': 'application/json'
            },
            body: JSON.stringify({
                fr_info_ids: selectedFRs,
                is_selected: true
            }),
            _timeoutMs: 30000,
            _retries: 1
        })
            .then(response => {
                console.log('API response status:', response.status);
                return response.json();
            })
            .then(data => {
                console.log('API response data:', data);
                if (data.success) {
                    showNotification('success', 'Thành công!', `Đã lưu ${selectedFRs.length} Functional Requirements thành công (${data.updated_count} bản ghi được cập nhật).`);
                    // Mark that selections have been saved (but keep button visible for additional selections)
                    window.frSelectionsSaved = true;
                    // Cập nhật lock status cho các step
                    updateStepLocks();

                    // Ensure cached data is marked as fresh after saving selections
                    // This prevents unnecessary re-analysis on page refresh
                    localStorage.setItem('fr_cache_fresh', Date.now().toString());
                } else {
                    showNotification('error', 'Lỗi!', data.message || 'Failed to save FR selections.');
                    // Restore button on error
                    button.innerHTML = originalText;
                    button.disabled = false;
                }
            })
            .catch(error => {
                console.error('Error saving FR selections:', error);
                showNotification('error', 'Lỗi!', 'An error occurred while saving FR selections.');
                // Restore button on error
                button.innerHTML = originalText;
                button.disabled = false;
                console.error('Error saving FR selections:', error);
                showNotification('error', 'Lỗi!', 'Failed to save FR selections.');
            })
            .finally(() => {
                button.innerHTML = originalText;
                button.disabled = false;
            });
    }

    function showFRDetails(fr, frInfoId) {
        // Create modal for FR details
        const modalHtml = `
        <div class="modal fade" id="frDetailModal" tabindex="-1" aria-labelledby="frDetailModalLabel" aria-hidden="true">
            <div class="modal-dialog modal-lg">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="frDetailModalLabel">
                            <i class="bi bi-card-text me-2"></i>${fr.fr_group}
                        </h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <div class="row">
                            <div class="col-md-8">
                                <div class="mb-3">
                                    <strong class="text-primary">📋 FR Group:</strong>
                                    <div class="mt-1">
                                        <code class="bg-light px-2 py-1 rounded">${fr.fr_group}</code>
                                    </div>
                                </div>
                                <div class="mb-3">
                                    <strong class="text-primary">📝 Description:</strong>
                                    <div class="mt-2 p-3 bg-light rounded">
                                        ${fr.description || '<em class="text-muted">No description available.</em>'}
                                    </div>
                                </div>
                                <div class="mb-3">
                                    <strong class="text-primary">🏷️ Name:</strong>
                                    <div class="mt-1">
                                        <span class="badge bg-info fs-6">${fr.name || fr.fr_group.split(':', 1)[1]?.trim() || 'N/A'}</span>
                                    </div>
                                </div>
                            </div>
                            <div class="col-md-4">
                                <div class="card border">
                                    <div class="card-body">
                                        <h6 class="card-title text-primary">ℹ️ Details</h6>
                                        <div class="mb-2">
                                            <strong>ID:</strong>
                                                <code class="small">${frInfoId || 'N/A'}</code>
                                        </div>
                                        <div class="mb-2">
                                            <strong>Status:</strong>
                                            <span class="badge ${fr.is_selected ? 'bg-success' : 'bg-secondary'} ms-1">
                                                ${fr.is_selected ? 'Selected' : 'Not Selected'}
                                            </span>
                                        </div>
                                        <div class="mb-2">
                                            <strong>Type:</strong>
                                            <span class="badge bg-light text-dark">Functional Requirement</span>
                                        </div>
                                        ${fr.documents && fr.documents.length > 0 ? `
                                        <div class="mb-2">
                                            <strong>Documents:</strong>
                                            <div class="mt-1">
                                                ${fr.documents.map(doc => `<small class="badge bg-secondary me-1">${doc.doc}:${doc.heading}</small>`).join('')}
                                            </div>
                                        </div>
                                        ` : ''}
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">
                            <i class="bi bi-x-circle me-1"></i>Close
                        </button>
                        <button type="button" class="btn btn-primary" onclick="toggleFRSelection('${frInfoId}', ${!fr.is_selected})">
                            <i class="bi bi-${fr.is_selected ? 'dash-circle' : 'check-circle'} me-1"></i>
                            ${fr.is_selected ? 'Deselect' : 'Select'} FR
                        </button>
                    </div>
                </div>
            </div>
        </div>
    `;

        // Remove existing modal if any
        const existingModal = document.getElementById('frDetailModal');
        if (existingModal) {
            existingModal.remove();
        }

        // Add modal to body
        document.body.insertAdjacentHTML('beforeend', modalHtml);

        // Show modal
        const modal = new bootstrap.Modal(document.getElementById('frDetailModal'));
        modal.show();
    }

    function toggleFRSelection(frId, select) {
        // Update checkbox state
        const checkbox = document.querySelector(`input[type="checkbox"][value="${frId}"]`);
        if (checkbox) {
            checkbox.checked = select;

            // Update badge
            const badge = checkbox.closest('.card-body').querySelector('.badge');
            if (badge) {
                if (select) {
                    badge.className = 'badge bg-success';
                    badge.textContent = 'Selected';
                } else {
                    badge.className = 'badge bg-secondary';
                    badge.textContent = 'Not Selected';
                }
            }
        }

        // Close modal
        const modal = bootstrap.Modal.getInstance(document.getElementById('frDetailModal'));
        if (modal) {
            modal.hide();
        }

        // Show success message
        showNotification('success', 'FR Updated', `FR has been ${select ? 'selected' : 'deselected'}. Remember to save your selections!`);
    }


    function createSectionCard(section) {
        const col = document.createElement('div');
        col.className = 'col-md-6 mb-3';

        const card = document.createElement('div');
        card.className = 'card section-card';

        const cardBody = document.createElement('div');
        cardBody.className = 'card-body';

        const formCheck = document.createElement('div');
        formCheck.className = 'form-check';

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'form-check-input section-checkbox';
        checkbox.value = section.id;
        checkbox.id = `section_${section.id}`;
        checkbox.checked = section.is_selected;

        const label = document.createElement('label');
        label.className = 'form-check-label w-100';
        label.htmlFor = `section_${section.id}`;

        const flexDiv = document.createElement('div');
        flexDiv.className = 'd-flex justify-content-between align-items-start';

        const contentDiv = document.createElement('div');
        contentDiv.className = 'flex-grow-1';

        const badgeClass = section.section_type ? `bg-${section.section_type}` : 'bg-secondary';
        const displayTitle = section.section_title || section.title;
        const displayContent = section.section_content || section.content;
        const truncatedContent = displayContent.split(' ').slice(0, 20).join(' ') + (displayContent.split(' ').length > 20 ? '...' : '');

        const title = document.createElement('h6');
        title.className = 'card-title mb-2';

        const badge = document.createElement('span');
        badge.className = `badge ${badgeClass} me-2`;
        badge.textContent = section.get_section_type_display || section.type_display;

        const titleText = document.createElement('span');
        titleText.textContent = displayTitle;

        title.appendChild(badge);
        title.appendChild(titleText);

        const content = document.createElement('p');
        content.className = 'card-text text-muted small';
        content.textContent = truncatedContent;

        contentDiv.appendChild(title);
        contentDiv.appendChild(content);

        if (section.document_name) {
            const small = document.createElement('small');
            small.className = 'text-muted';
            const icon = document.createElement('i');
            icon.className = 'bi bi-file-earmark';
            small.appendChild(icon);
            small.appendChild(document.createTextNode(' From: ' + section.document_name));
            contentDiv.appendChild(small);
        }
        flexDiv.appendChild(contentDiv);
        label.appendChild(flexDiv);

        formCheck.appendChild(checkbox);
        formCheck.appendChild(label);
        cardBody.appendChild(formCheck);
        card.appendChild(cardBody);
        col.appendChild(card);

        // Add click handler
        card.addEventListener('click', function (e) {
            if (e.target.type !== 'checkbox') {
                checkbox.checked = !checkbox.checked;
            }
        });

        return col;
    }

    function selectAllSections() {
        document.querySelectorAll('.section-checkbox').forEach(checkbox => {
            checkbox.checked = true;
        });
    }

    function deselectAllSections() {
        document.querySelectorAll('.section-checkbox').forEach(checkbox => {
            checkbox.checked = false;
        });
    }

    // Save Section Selection
    function saveSectionSelection() {
        const selectedSections = Array.from(document.querySelectorAll('.section-checkbox:checked'))
            .map(checkbox => parseInt(checkbox.value));

        if (selectedSections.length === 0) {
            showNotification('warning', 'Cảnh báo', 'Vui lòng chọn ít nhất một section');
            return;
        }

        const button = document.querySelector('button[onclick="saveSectionSelection()"]');
        const originalText = button.innerHTML;
        button.innerHTML = '<i class="bi bi-hourglass-split"></i> Saving...';
        button.disabled = true;

        fetch(`/project/{{ project.uuid }}/sections/update/`, {
            method: 'POST',
            headers: {
                'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                selected_sections: selectedSections
            }),
            _timeoutMs: 60000
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showNotification('success', 'Thành công!', data.message);
                    // Hide save button and show next step option
                    document.getElementById('saveSelectionContainer').style.display = 'none';
                    // Enable next button
                    document.getElementById('nextButton').disabled = false;
                } else {
                    showNotification('error', 'Lỗi!', data.message);
                }
            })
            .catch(error => {
                console.error('Error:', error);
                showNotification('error', 'Lỗi!', 'Lỗi mạng: ' + error.message);
            })
            .finally(() => {
                button.innerHTML = originalText;
                button.disabled = false;
            });
    }

    // Generate Test Suite
    function generateTestSuite() {
        const button = document.getElementById('generateTestSuiteBtn');
        const originalText = button.innerHTML;

        button.innerHTML = '<i class="bi bi-hourglass-split"></i> Generating...';
        button.disabled = true;

        fetch(`/project/{{ project.uuid }}/test-suite/create/`, {
            method: 'POST',
            headers: {
                'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value,
                'Content-Type': 'application/json'
            },
            _timeoutMs: 120000
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showTestSuiteResult(true, data.message, data);
                } else {
                    showTestSuiteResult(false, data.message, null);
                }
            })
            .catch(error => {
                console.error('Error:', error);
                showTestSuiteResult(false, 'Network error: ' + error.message, null);
            })
            .finally(() => {
                button.innerHTML = originalText;
                button.disabled = false;
            });
    }

    function showTestSuiteResult(success, message, data) {
        const resultContainer = document.getElementById('testSuiteResult');
        const alertClass = success ? 'alert-success' : 'alert-danger';
        const icon = success ? 'bi-check-circle' : 'bi-exclamation-triangle';

        let resultHtml = `
        <div class="alert ${alertClass}">
            <i class="bi ${icon}"></i> <strong>${success ? 'Success!' : 'Error!'}</strong> ${message}
        </div>
    `;

        if (success && data) {
            resultHtml += `
            <div class="mt-3">
                <h6>Test Suite Created:</h6>
                <div class="card">
                    <div class="card-body">
                        <h6 class="card-title">${data.test_suite_name}</h6>
                        <p class="card-text">${data.message}</p>
                        <a href="/project/{{ project.uuid }}/" class="btn btn-primary btn-sm">View Project</a>
                    </div>
                </div>
            </div>
        `;
        }

        resultContainer.innerHTML = resultHtml;
        resultContainer.style.display = 'block';
    }

    // Legacy showAlert function - now redirects to showNotification
    function showAlert(type, title, message) {
        // Map old alert types to new notification types
        const typeMap = {
            'success': 'success',
            'error': 'error',
            'warning': 'warning',
            'info': 'info',
            'danger': 'error'
        };

        const notificationType = typeMap[type] || 'info';
        showNotification(notificationType, title, message);
    }

    // Test API Integration Function
    function testApiIntegration() {
        const button = document.querySelector('button[onclick="testApiIntegration()"]');
        const originalText = button.innerHTML;

        // Show loading state
        button.innerHTML = '<i class="bi bi-hourglass-split"></i> Testing API...';
        button.disabled = true;

        fetch(`/project/{{ project.uuid }}/ai/test/`, {
            method: 'POST',
            headers: {
                'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value,
                'Content-Type': 'application/json'
            }
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Show success message
                    showApiTestResult(true, data.message, data.api_response);
                } else {
                    // Show error message
                    showApiTestResult(false, data.message, null);
                }
            })
            .catch(error => {
                console.error('Error:', error);
                showApiTestResult(false, 'Network error: ' + error.message, null);
            })
            .finally(() => {
                // Reset button state
                button.innerHTML = originalText;
                button.disabled = false;
            });
    }

    function showApiTestResult(success, message, apiResponse) {
        // Create modal or alert to show result
        const alertClass = success ? 'alert-success' : 'alert-danger';
        const icon = success ? 'bi-check-circle' : 'bi-exclamation-triangle';

        let responseHtml = '';
        if (apiResponse && success) {
            responseHtml = `
            <div class="mt-3">
                <h6>API Response:</h6>
                <pre class="bg-light p-2 rounded" style="font-size: 0.8em; max-height: 200px; overflow-y: auto;">
${JSON.stringify(apiResponse, null, 2)}
                </pre>
            </div>
        `;
        }

        const alertHtml = `
        <div class="alert ${alertClass} alert-dismissible fade show" role="alert">
            <i class="bi ${icon}"></i> <strong>${success ? 'Success!' : 'Error!'}</strong> ${message}
            ${responseHtml}
            <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
        </div>
    `;

        // Insert alert before the test button
        const testButtonContainer = document.querySelector('button[onclick="testApiIntegration()"]').parentElement;
        testButtonContainer.insertAdjacentHTML('beforebegin', alertHtml);

        // Auto dismiss after 10 seconds
        setTimeout(() => {
            const alert = testButtonContainer.previousElementSibling;
            if (alert && alert.classList.contains('alert')) {
                alert.remove();
            }
        }, 10000);
    }
</script>

<script>
    // Delete preprocessed document by doc_id via backend endpoint that calls external API
    function getCookie(name) {
        const value = `; ${document.cookie}`;
        const parts = value.split(`; ${name}=`);
        if (parts.length === 2) return parts.pop().split(';').shift();
    }

    function deletePreprocessedDocument(projectUuid, docId, fallbackUrl, btnEl) {
        // Prefer API delete when docId exists; otherwise fall back to legacy URL (server will also attempt API if possible)
        if (!docId) {
            if (fallbackUrl) {
                window.location.href = fallbackUrl;
            }
            return;
        }

        if (!confirm('Bạn có chắc muốn xoá tài liệu này?')) {
            return;
        }

        const csrftoken = document.querySelector('[name=csrfmiddlewaretoken]')?.value || getCookie('csrftoken') || '';

        // UI: disable button without spinner; keep icon intact
        if (btnEl) {
            if (btnEl.dataset.deleting === '1') return; // prevent double delete
            btnEl.dataset.deleting = '1';
            btnEl.disabled = true;
            btnEl.classList.add('disabled');
            btnEl.setAttribute('aria-disabled', 'true');
            btnEl.style.opacity = '0.7';
        }

        fetch(`/project/${projectUuid}/preprocessed-document/${encodeURIComponent(docId)}/delete/`, {
            method: 'POST',
            headers: {
                'X-CSRFToken': csrftoken,
                'Accept': 'application/json'
            },
            _noLoading: true,
            _timeoutMs: 30000
        })
            .then(async res => {
                try { return await res.json(); } catch (_) {
                    return { success: res.ok, message: res.ok ? 'Deleted' : 'Delete failed' };
                }
            })
            .then(data => {
                if (data.success) {
                    // Remove the nearest list/card element without full page reload
                    if (btnEl) {
                        const container = btnEl.closest('.list-group-item, .card');
                        if (container) {
                            // If it's a card inside grid, remove the column wrapper for clean layout
                            const col = container.closest('.col-md-6, .col-lg-4, .col-12');
                            (col || container).remove();
                        } else {
                            btnEl.remove();
                        }
                    }
                    // Update sections if on step 3
                    try { loadSections(); } catch (e) { }
                    showNotification('success', 'Đã xóa!', data.message || 'Tài liệu đã được xóa thành công.');
                    // Refresh back to step 1 after successful deletion
                    window.location.href = `/project/{{ project.uuid }}/?step=1`;
                } else {
                    showNotification('error', 'Lỗi!', data.message || 'Không thể xóa tài liệu.');
                    if (btnEl) {
                        btnEl.disabled = false;
                        btnEl.classList.remove('disabled');
                        btnEl.removeAttribute('aria-disabled');
                        btnEl.style.opacity = '';
                        delete btnEl.dataset.deleting;
                    }
                }
            })
            .catch(err => {
                console.error('Delete error:', err);
                showNotification('error', 'Lỗi!', 'Lỗi mạng: ' + (err?.message || err));
                if (btnEl) {
                    btnEl.disabled = false;
                    btnEl.classList.remove('disabled');
                    btnEl.removeAttribute('aria-disabled');
                    btnEl.style.opacity = '';
                    delete btnEl.dataset.deleting;
                }
            });
    }
</script>

<!-- Document View Modal -->
<div class="modal fade" id="documentViewModal" tabindex="-1" aria-labelledby="documentViewModalLabel"
    aria-hidden="true">
    <div class="modal-dialog modal-xl">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="documentViewModalLabel">Viewing Document</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div id="documentViewer" style="height: 70vh;">
                    <div class="text-center py-5">
                        <div class="spinner-border text-primary" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                        <p class="mt-2">Loading document...</p>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                <button type="button" class="btn btn-primary" id="downloadBtn">Download</button>
            </div>
        </div>
    </div>
</div>

<script>
    function viewDocument(fileId, filename, link) {
        let fileUrl;

        if (fileId) {
            const minioBaseUrl = "https://minio-api.truong51972.id.vn";
            const bucketName = "apit-project";
            fileUrl = `${minioBaseUrl}/${bucketName}/${fileId}`;
        } else if (link) {
            fileUrl = link;
        } else {
            showNotification('warning', 'Cảnh báo', 'File không khả dụng để xem');
            return;
        }

        const safeFilename = filename || (fileId ? fileId.split('/').pop() : (link ? link.split('/').pop() : 'Document'));
        document.getElementById('documentViewModalLabel').textContent = `Viewing: ${safeFilename}`;

        const downloadBtn = document.getElementById('downloadBtn');

        const viewer = document.getElementById('documentViewer');
        viewer.innerHTML = `
        <div class="text-center py-5">
            <div class="spinner-border text-primary" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
            <p class="mt-2">Loading document...</p>
        </div>
    `;

        const modal = new bootstrap.Modal(document.getElementById('documentViewModal'));
        modal.show();

        setTimeout(() => {
            // Special handling for Google Drive sharing links
            try {
                const urlObj = new URL(fileUrl);
                if (urlObj.hostname.includes('drive.google.com')) {
                    // Match /file/d/<id>/...
                    const match = fileUrl.match(/\/file\/d\/([^\/]+)/);
                    const fileIdGg = match && match[1] ? match[1] : null;
                    if (fileIdGg) {
                        const previewUrl = `https://drive.google.com/file/d/${fileIdGg}/preview`;
                        const downloadUrl = `https://drive.google.com/uc?export=download&id=${fileIdGg}`;
                        viewer.innerHTML = `<iframe src="${previewUrl}" width="100%" height="100%" style="border: none;"></iframe>`;
                        downloadBtn.onclick = function () { window.open(downloadUrl, '_blank'); };
                        return;
                    }
                }
            } catch (e) { /* ignore URL parse errors */ }

            const lower = safeFilename.toLowerCase();
            const hasExt = lower.includes('.')
            const ext = hasExt ? lower.split('.').pop() : '';
            const encodedUrl = encodeURIComponent(fileUrl);

            // Prefer Office viewer for Word docs (works around CORS/X-Frame-Options for many hosts)
            if (ext === 'doc' || ext === 'docx') {
                const officeSrc = `https://view.officeapps.live.com/op/embed.aspx?src=${encodedUrl}`;
                viewer.innerHTML = `<iframe src="${officeSrc}" width="100%" height="100%" style="border: none;"></iframe>`;
                downloadBtn.onclick = function () { window.open(fileUrl, '_blank'); };
                return;
            }

            // PDF: try direct, else Google viewer fallback
            if (ext === 'pdf' || (!hasExt && !fileId)) {
                const iframe = document.createElement('iframe');
                iframe.width = '100%';
                iframe.height = '100%';
                iframe.style.border = 'none';
                iframe.src = fileUrl;

                let loaded = false;
                const fallbackTimer = setTimeout(() => {
                    if (!loaded) {
                        const googleSrc = `https://drive.google.com/viewerng/viewer?embedded=true&url=${encodedUrl}`;
                        viewer.innerHTML = `<iframe src="${googleSrc}" width="100%" height="100%" style="border: none;"></iframe>`;
                    }
                }, 2000);

                iframe.onload = function () { loaded = true; clearTimeout(fallbackTimer); };
                viewer.innerHTML = '';
                viewer.appendChild(iframe);
                downloadBtn.onclick = function () { window.open(fileUrl, '_blank'); };
                return;
            }

            // Default: no inline preview, provide open button
            viewer.innerHTML = `
            <div class="text-center py-5">
                <i class="bi bi-file-earmark" style="font-size: 3rem; color: #6c757d;"></i>
                <h5 class="mt-3">File Preview Not Available</h5>
                <p class="text-muted">This file type cannot be previewed directly in the browser.</p>
                <button class="btn btn-primary" onclick="window.open('${fileUrl}', '_blank')">Open in New Tab</button>
            </div>
        `;
            downloadBtn.onclick = function () { window.open(fileUrl, '_blank'); };
        }, 300);
    }
</script>